import { gql } from 'apollo-server-express';

export const typeDefs = gql`
  type Admin {
    id: ID!
    email: String!
    password: String!
    name: String
    role: String
  }

  type Restaurant {
    _id: ID!
    orderId: Int
    name: String!
    image: String
    address: String!
    phone: String
    # Admin-facing optional fields (populated progressively as schema evolves)
    unique_restaurant_id: ID
    orderPrefix: String
    slug: String
    deliveryTime: String
    minimumOrder: Float
    isActive: Boolean
    commissionRate: Float
    username: String
    tax: Float
    shopType: String
    owner: Owner
  }

  type Owner {
    _id: ID
    email: String
    isActive: Boolean
  }

  type Location {
    coordinates: [Float!]
  }

  "Serviceable locations (state/city)"
  type ServiceLocation {
    id: ID!
    state: String!
    city: String!
    latitude: Float!
    longitude: Float!
    isAvailable: Boolean!
  }

  type OpeningTime {
    day: String!
    times: [TimeSlot!]
  }

  type TimeSlot {
    startTime: String!
    endTime: String!
  }

  type RestaurantPreview {
    _id: ID!
    name: String!
    image: String
    logo: String
    slug: String
    shopType: String
    deliveryTime: String
    location: Location
    reviewAverage: Float
    cuisines: [String!]
    openingTimes: [OpeningTime!]
    isAvailable: Boolean
    isActive: Boolean
  }

  type NearByRestaurantsResponse {
    restaurants: [RestaurantPreview!]!
  }

  type RestaurantsPaginatedResponse {
    data: [Restaurant!]!
    totalCount: Int!
    currentPage: Int!
    totalPages: Int!
  }

  type MenuItem {
    id: ID!
    restaurant_id: ID!
    name: String!
    price: Float!
  }

  type OrderItem {
    id: ID!
    title: String!
    quantity: Int!
    price: Float!
    variation: String
    addons: String
  }

  type Order {
    id: ID!
    orderId: String!
    restaurantId: ID!
    orderStatus: String!
    deliveryAddress: String
    deliveryLatitude: Float
    deliveryLongitude: Float
    createdAt: String!
    items: [OrderItem!]!
    total: Float!
    paymentMethod: String
    paidAmount: Float
    orderAmount: Float
    deliveryCharges: Float
    tipping: Float
    taxationAmount: Float
    instructions: String
    orderDate: String
    isPickedUp: Boolean
  }

  input CreateOrderItemInput {
    title: String!
    quantity: Int!
    price: Float!
  }

  input CreateOrderInput {
    restaurantId: ID!
    items: [CreateOrderItemInput!]!
    deliveryAddress: String
    deliveryLatitude: Float
    deliveryLongitude: Float
  }

  "Input for more complete order placement (aligned with Enatega schema subset)"
  input AddressInput {
    deliveryAddress: String!
    latitude: Float
    longitude: Float
  }

  input OrderInput {
    title: String!
    quantity: Int!
    price: Float!
    variation: String
    addons: String
  }

  type User {
    id: ID!
    username: String!
    password: String!
    email: String!
  }

  type OwnerLoginResponse {
    userId: String!
    token: String!
    email: String!
    userType: String!
    restaurants: [Restaurant!]!
    permissions: [String!]!
    userTypeId: String
    image: String
    name: String
  }

  type Query {
    admins: [Admin]
    restaurants: [Restaurant]
    restaurant(id: ID!): Restaurant
    menuItems: [MenuItem]
    menuItemsByRestaurant(restaurantId: ID!): [MenuItem!]!
    users: [User]
    availableLocations: [ServiceLocation!]!
    """
    Primary query for web app restaurant listing.
    - latitude/longitude: User location (web app defaults to Uyo: 5.0389, 7.9135)
    - city/state: Optional filters for restaurant address (e.g., "Calabar, Cross River")
    - page/limit: Pagination (default: page 1, limit 10)
    - shopType: Filter by "restaurant" or "grocery" (optional)
    
    Returns ALL restaurants when city/state are omitted (common case for web app).
    """
    nearByRestaurantsPreview(
      latitude: Float
      longitude: Float
      page: Int
      limit: Int
      shopType: String
      city: String
      state: String
    ): NearByRestaurantsResponse
    recentOrderRestaurantsPreview(latitude: Float!, longitude: Float!): [RestaurantPreview!]
    mostOrderedRestaurantsPreview(
      latitude: Float!
      longitude: Float!
      page: Int
      limit: Int
      shopType: String
    ): [RestaurantPreview!]

    # Admin UI: List restaurants with pagination and optional search
    restaurantsPaginated(page: Int, limit: Int, search: String): RestaurantsPaginatedResponse!
  }

  type Mutation {
    ownerLogin(email: String!, password: String!): OwnerLoginResponse
    createOrder(input: CreateOrderInput!): Order!
    placeOrder(
      restaurant: String!
      orderInput: [OrderInput!]!
      paymentMethod: String!
      couponCode: String
      tipping: Float!
      taxationAmount: Float!
      address: AddressInput!
      orderDate: String!
      isPickedUp: Boolean!
      deliveryCharges: Float!
      instructions: String
    ): Order!
  }
`;

export const resolvers = {
  Query: {
    admins: async (_, __, { db }) => db.all('SELECT * FROM admins'),
    restaurants: async (_, __, { db }) => {
      const rows = await db.all('SELECT * FROM restaurants');
      return rows.map(row => ({ ...row, _id: row.id }));
    },
    restaurant: async (_, { id }, { db }) => {
      const row = await db.get('SELECT * FROM restaurants WHERE id = ?', [id]);
      if (!row) return null;
      return { ...row, _id: row.id };
    },
    menuItems: async (_, __, { db }) => db.all('SELECT * FROM menu_items'),
    menuItemsByRestaurant: async (_, { restaurantId }, { db }) => {
      return await db.all('SELECT * FROM menu_items WHERE restaurant_id = ?', [restaurantId]);
    },
    users: async (_, __, { db }) => db.all('SELECT * FROM users'),
    availableLocations: async (_, __, { db }) => {
      const rows = await db.all('SELECT id, state, city, latitude, longitude, isAvailable FROM locations WHERE isAvailable = 1');
      return rows.map(r => ({
        id: r.id,
        state: r.state,
        city: r.city,
        latitude: r.latitude,
        longitude: r.longitude,
        isAvailable: Boolean(r.isAvailable)
      }));
    },
    
    nearByRestaurantsPreview: async (_, { latitude, longitude, page = 1, limit = 10, shopType, city, state }, { db }) => {
      // Web app calls this with latitude/longitude only (no city/state).
      // Return ALL restaurants when no city/state filter is provided.
      // Optionally filter by city/state if provided (e.g., "Calabar, Cross River").
      const offset = (page - 1) * limit;
      let query = 'SELECT * FROM restaurants';
      const whereClauses = [];
      const params = [];

      // Filter by address (stored as "City, State") when city/state provided
      if (city && state) {
        // Case-insensitive exact match on full address
        whereClauses.push('LOWER(address) = LOWER(?)');
        params.push(`${String(city).trim()}, ${String(state).trim()}`);
      } else if (city) {
        // Match rows that start with the city name
        whereClauses.push('LOWER(address) LIKE LOWER(?)');
        params.push(`${String(city).trim()}, %`);
      } else if (state) {
        // Match rows that end with the state name
        whereClauses.push('LOWER(address) LIKE LOWER(?)');
        params.push(`%, ${String(state).trim()}`);
      }
      // else: No city/state filter - return all restaurants (common case for lat/lon only queries)

      if (shopType) {
        // If schema has shopType, this will work; else it's ignored by not adding the clause
        // We won't add a clause for shopType here because base restaurants table may not have it
      }

      if (whereClauses.length > 0) {
        query += ' WHERE ' + whereClauses.join(' AND ');
      }

      query += ' ORDER BY name ASC LIMIT ? OFFSET ?';
      params.push(limit, offset);

      const rows = await db.all(query, params);
      
      // Default to Cross River State, Nigeria coordinates if not provided
      const defaultLat = latitude || 5.0000;
      const defaultLng = longitude || 8.3200;
      
      const restaurants = rows.map(row => ({
        _id: row.id.toString(),
        name: row.name,
        image: row.image,
        logo: row.image, // Using image as logo for now
        slug: row.name.toLowerCase().replace(/\s+/g, '-'),
        shopType: 'restaurant',
        deliveryTime: '25-35 min',
        location: {
          coordinates: [defaultLng, defaultLat] // [longitude, latitude]
        },
        reviewAverage: 4.5,
        cuisines: ['Nigerian', 'African', 'Local'],
        openingTimes: [
          {
            day: 'Monday',
            times: [{ startTime: '09:00', endTime: '22:00' }]
          },
          {
            day: 'Tuesday',
            times: [{ startTime: '09:00', endTime: '22:00' }]
          },
          {
            day: 'Wednesday',
            times: [{ startTime: '09:00', endTime: '22:00' }]
          },
          {
            day: 'Thursday',
            times: [{ startTime: '09:00', endTime: '22:00' }]
          },
          {
            day: 'Friday',
            times: [{ startTime: '09:00', endTime: '23:00' }]
          },
          {
            day: 'Saturday',
            times: [{ startTime: '10:00', endTime: '23:00' }]
          },
          {
            day: 'Sunday',
            times: [{ startTime: '10:00', endTime: '21:00' }]
          }
        ],
        isAvailable: true,
        isActive: true
      }));
      
      return { restaurants };
    },
    
    recentOrderRestaurantsPreview: async (_, { latitude, longitude }, { db }) => {
      const rows = await db.all('SELECT * FROM restaurants LIMIT 5');
      return rows.map(row => ({
        _id: row.id.toString(),
        name: row.name,
        image: row.image,
        logo: row.image,
        slug: row.name.toLowerCase().replace(/\s+/g, '-'),
        shopType: 'restaurant',
        deliveryTime: '20-30 min',
        location: {
          coordinates: [latitude || -74.006, longitude || 40.7128]
        },
        reviewAverage: 4.3,
        cuisines: ['Popular'],
        openingTimes: [
          {
            day: 'Monday',
            times: [{ startTime: '09:00', endTime: '22:00' }]
          }
        ],
        isAvailable: true,
        isActive: true
      }));
    },
    
    mostOrderedRestaurantsPreview: async (_, { latitude, longitude, page = 1, limit = 10, shopType }, { db }) => {
      const offset = (page - 1) * limit;
      let query = 'SELECT * FROM restaurants';
      let params = [];
      
      if (shopType) {
        query += ' WHERE shopType = ?';
        params.push(shopType);
      }
      
      query += ' ORDER BY name LIMIT ? OFFSET ?';
      params.push(limit, offset);
      
      const rows = await db.all(query, params);
      return rows.map(row => ({
        _id: row.id.toString(),
        name: row.name,
        image: row.image,
        logo: row.image,
        slug: row.name.toLowerCase().replace(/\s+/g, '-'),
        shopType: 'restaurant',
        deliveryTime: '30-40 min',
        location: {
          coordinates: [latitude || -74.006, longitude || 40.7128]
        },
        reviewAverage: 4.7,
        cuisines: ['Popular', 'Trending'],
        openingTimes: [
          {
            day: 'Monday',
            times: [{ startTime: '09:00', endTime: '22:00' }]
          }
        ],
        isAvailable: true,
        isActive: true
      }));
    },

    // Admin UI: restaurantsPaginated
    restaurantsPaginated: async (_,{ page = 1, limit = 10, search }, { db }) => {
      const safePage = Math.max(1, Number(page) || 1);
      const safeLimit = Math.min(100, Math.max(1, Number(limit) || 10));
      const offset = (safePage - 1) * safeLimit;

      // Build where clause for search across name and address
      const where = [];
      const params = [];
      if (search && String(search).trim()) {
        where.push('(LOWER(name) LIKE LOWER(?) OR LOWER(address) LIKE LOWER(?))');
        const like = `%${String(search).trim()}%`;
        params.push(like, like);
      }

      const whereSql = where.length ? `WHERE ${where.join(' AND ')}` : '';

      // Count total
      const countRow = await db.get(`SELECT COUNT(*) as cnt FROM restaurants ${whereSql}`, params);
      const totalCount = Number(countRow?.cnt || 0);
      const totalPages = Math.max(1, Math.ceil(totalCount / safeLimit));

      // Fetch page
      const pageRows = await db.all(
        `SELECT * FROM restaurants ${whereSql} ORDER BY name ASC LIMIT ? OFFSET ?`,
        [...params, safeLimit, offset]
      );

      const data = pageRows.map(row => ({
        _id: row.id?.toString() ?? null,
        orderId: null,
        name: row.name,
        image: row.image,
        address: row.address,
        phone: row.phone || null,
        unique_restaurant_id: row.unique_restaurant_id || `RES-${row.id}`,
        orderPrefix: row.order_prefix || 'ORD',
        slug: row.slug || (row.name ? row.name.toLowerCase().replace(/\s+/g, '-') : null),
        deliveryTime: row.delivery_time || '25-35 min',
        minimumOrder: row.minimum_order ?? 0,
        isActive: row.is_active != null ? Boolean(row.is_active) : true,
        commissionRate: row.commission_rate ?? 0,
        username: row.username || (row.name ? row.name.toLowerCase().replace(/\s+/g, '') : null),
        tax: row.tax ?? 0,
        shopType: row.shop_type || 'restaurant',
        owner: { 
          _id: row.owner_id != null ? String(row.owner_id) : '1', 
          email: row.owner_email || 'owner@example.com', 
          isActive: row.owner_is_active != null ? Boolean(row.owner_is_active) : true 
        },
      }));

      return {
        data,
        totalCount,
        currentPage: safePage,
        totalPages,
      };
    }
  },
  Mutation: {
    createOrder: async (_,{ input }, { db }) => {
      // Ensure tables exist
      await db.exec(`
        CREATE TABLE IF NOT EXISTS orders (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          order_id TEXT UNIQUE NOT NULL,
          restaurant_id INTEGER NOT NULL,
          order_status TEXT DEFAULT 'PENDING',
          delivery_address TEXT,
          delivery_latitude REAL,
          delivery_longitude REAL,
          payment_method TEXT,
          paid_amount REAL,
          order_amount REAL,
          delivery_charges REAL,
          tipping REAL,
          taxation_amount REAL,
          instructions TEXT,
          order_date TEXT,
          is_picked_up INTEGER,
          created_at TEXT DEFAULT (datetime('now'))
        );
        CREATE TABLE IF NOT EXISTS order_items (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          order_id INTEGER NOT NULL,
          title TEXT NOT NULL,
          quantity INTEGER DEFAULT 1,
          price REAL DEFAULT 0,
          variation TEXT,
          addons TEXT,
          FOREIGN KEY (order_id) REFERENCES orders(id) ON DELETE CASCADE
        );
      `);

      const { restaurantId, items, deliveryAddress, deliveryLatitude, deliveryLongitude } = input;
      if (!items || items.length === 0) throw new Error('No items provided');
      const total = items.reduce((s, it) => s + (Number(it.price) || 0) * (Number(it.quantity) || 0), 0);

      const orderCode = `ORD-${Date.now()}`;
      // Transaction to avoid lock errors on concurrent writes
      let oid;
      try {
        await db.exec('BEGIN IMMEDIATE TRANSACTION');
        const result = await db.run(
          'INSERT INTO orders (order_id, restaurant_id, order_status, delivery_address, delivery_latitude, delivery_longitude, payment_method, paid_amount, order_amount, delivery_charges, tipping, taxation_amount, instructions, order_date, is_picked_up) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)',
          [
            orderCode,
            Number(restaurantId),
            'PENDING',
            deliveryAddress || null,
            deliveryLatitude || null,
            deliveryLongitude || null,
            'CASH',
            total,
            total,
            0,
            0,
            0,
            null,
            new Date().toISOString(),
            0
          ]
        );
        oid = result.lastID;

        for (const it of items) {
          await db.run(
            'INSERT INTO order_items (order_id, title, quantity, price, variation, addons) VALUES (?, ?, ?, ?, ?, ?)',
            [oid, it.title, Number(it.quantity) || 1, Number(it.price) || 0, null, null]
          );
        }
        await db.exec('COMMIT');
      } catch (err) {
        await db.exec('ROLLBACK');
        throw err;
      }

      const rows = await db.all('SELECT id, title, quantity, price, variation, addons FROM order_items WHERE order_id = ?', [oid]);
      const orderRow = await db.get(`
        SELECT 
          id, 
          order_id as orderId, 
          restaurant_id as restaurantId, 
          order_status as orderStatus, 
          delivery_address as deliveryAddress, 
          delivery_latitude as deliveryLatitude,
          delivery_longitude as deliveryLongitude,
          payment_method as paymentMethod,
          paid_amount as paidAmount,
          order_amount as orderAmount,
          delivery_charges as deliveryCharges,
          tipping as tipping,
          taxation_amount as taxationAmount,
          instructions as instructions,
          order_date as orderDate,
          is_picked_up as isPickedUp,
          created_at as createdAt 
        FROM orders WHERE id = ?
      `, [oid]);
      return { ...orderRow, items: rows, total };
    },
    placeOrder: async (_,{ restaurant, orderInput, paymentMethod, couponCode, tipping, taxationAmount, address, orderDate, isPickedUp, deliveryCharges, instructions }, { db }) => {
      // Ensure tables exist with extended columns (ignore errors if already exist)
      await db.exec(`
        CREATE TABLE IF NOT EXISTS orders (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          order_id TEXT UNIQUE NOT NULL,
          restaurant_id INTEGER NOT NULL,
          order_status TEXT DEFAULT 'PENDING',
          delivery_address TEXT,
          delivery_latitude REAL,
          delivery_longitude REAL,
          payment_method TEXT,
          paid_amount REAL,
          order_amount REAL,
          delivery_charges REAL,
          tipping REAL,
          taxation_amount REAL,
          instructions TEXT,
          order_date TEXT,
          is_picked_up INTEGER,
          created_at TEXT DEFAULT (datetime('now'))
        );
        CREATE TABLE IF NOT EXISTS order_items (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          order_id INTEGER NOT NULL,
          title TEXT NOT NULL,
          quantity INTEGER DEFAULT 1,
          price REAL DEFAULT 0,
          variation TEXT,
          addons TEXT,
          FOREIGN KEY (order_id) REFERENCES orders(id) ON DELETE CASCADE
        );
      `);

      const restaurantId = Number(restaurant);
      const items = orderInput || [];
      if (!items.length) throw new Error('No items provided');
      const subtotal = items.reduce((s, it) => s + (Number(it.price) || 0) * (Number(it.quantity) || 0), 0);
      const orderAmount = subtotal + (Number(taxationAmount) || 0) + (Number(deliveryCharges) || 0) + (Number(tipping) || 0);
      const paidAmount = orderAmount; // demo: assume full paid
      const orderCode = `ORD-${Date.now()}`;

        // Use transaction to prevent "database is locked" errors
        let oid;
        try {
          await db.exec('BEGIN IMMEDIATE TRANSACTION');
        
          const result = await db.run(
            `INSERT INTO orders (
                order_id, restaurant_id, order_status, delivery_address, delivery_latitude, delivery_longitude,
                payment_method, paid_amount, order_amount, delivery_charges, tipping, taxation_amount, instructions, order_date, is_picked_up
             ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
            [
              orderCode,
              restaurantId,
              'PENDING',
              address?.deliveryAddress || null,
              address?.latitude ?? null,
              address?.longitude ?? null,
              paymentMethod,
              paidAmount,
              orderAmount,
              Number(deliveryCharges) || 0,
              Number(tipping) || 0,
              Number(taxationAmount) || 0,
              instructions || null,
              orderDate || new Date().toISOString(),
              isPickedUp ? 1 : 0
            ]
          );
          oid = result.lastID;
        
          for (const it of items) {
            await db.run(
              'INSERT INTO order_items (order_id, title, quantity, price, variation, addons) VALUES (?, ?, ?, ?, ?, ?)',
              [oid, it.title, Number(it.quantity) || 1, Number(it.price) || 0, it.variation || null, it.addons || null]
            );
          }
        
          await db.exec('COMMIT');
        } catch (error) {
          await db.exec('ROLLBACK');
          console.error('Order placement failed:', error);
          throw new Error(`Failed to place order: ${error.message}`);
        }

      const rows = await db.all('SELECT id, title, quantity, price, variation, addons FROM order_items WHERE order_id = ?', [oid]);
      const orderRow = await db.get(`
        SELECT 
          id, 
          order_id as orderId, 
          restaurant_id as restaurantId, 
          order_status as orderStatus, 
          delivery_address as deliveryAddress, 
          delivery_latitude as deliveryLatitude,
          delivery_longitude as deliveryLongitude,
          payment_method as paymentMethod,
          paid_amount as paidAmount,
          order_amount as orderAmount,
          delivery_charges as deliveryCharges,
          tipping as tipping,
          taxation_amount as taxationAmount,
          instructions as instructions,
          order_date as orderDate,
          is_picked_up as isPickedUp,
          created_at as createdAt 
        FROM orders WHERE id = ?
      `, [oid]);
      const total = orderAmount; // include charges for total display
      return { ...orderRow, items: rows, total };
    },
    ownerLogin: async (_, { email, password }, { db }) => {
      const admin = await db.get('SELECT * FROM admins WHERE email = ? AND password = ?', [email, password]);
      if (!admin) {
        throw new Error('Invalid credentials');
      }
      return {
        userId: admin.id.toString(),
        token: 'dummy-token-' + admin.id,
        email: admin.email,
        userType: 'ADMIN',
        restaurants: [],
        permissions: ['ADMIN'],
        userTypeId: admin.id.toString(),
        image: null,
        name: admin.name || 'Admin'
      };
    },
  },
};
