"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/iterall";
exports.ids = ["vendor-chunks/iterall"];
exports.modules = {

/***/ "(ssr)/./node_modules/iterall/index.mjs":
/*!****************************************!*\
  !*** ./node_modules/iterall/index.mjs ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $$asyncIterator: () => (/* binding */ $$asyncIterator),\n/* harmony export */   $$iterator: () => (/* binding */ $$iterator),\n/* harmony export */   createAsyncIterator: () => (/* binding */ createAsyncIterator),\n/* harmony export */   createIterator: () => (/* binding */ createIterator),\n/* harmony export */   forAwaitEach: () => (/* binding */ forAwaitEach),\n/* harmony export */   forEach: () => (/* binding */ forEach),\n/* harmony export */   getAsyncIterator: () => (/* binding */ getAsyncIterator),\n/* harmony export */   getAsyncIteratorMethod: () => (/* binding */ getAsyncIteratorMethod),\n/* harmony export */   getIterator: () => (/* binding */ getIterator),\n/* harmony export */   getIteratorMethod: () => (/* binding */ getIteratorMethod),\n/* harmony export */   isArrayLike: () => (/* binding */ isArrayLike),\n/* harmony export */   isAsyncIterable: () => (/* binding */ isAsyncIterable),\n/* harmony export */   isCollection: () => (/* binding */ isCollection),\n/* harmony export */   isIterable: () => (/* binding */ isIterable)\n/* harmony export */ });\n/**\n * Copyright (c) 2016, Lee Byron\n * All rights reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n * @ignore\n */\n\n/**\n * [Iterator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#iterator)\n * is a *protocol* which describes a standard way to produce a sequence of\n * values, typically the values of the Iterable represented by this Iterator.\n *\n * While described by the [ES2015 version of JavaScript](http://www.ecma-international.org/ecma-262/6.0/#sec-iterator-interface)\n * it can be utilized by any version of JavaScript.\n *\n * @external Iterator\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#iterator|MDN Iteration protocols}\n */\n\n/**\n * [Iterable](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#iterable)\n * is a *protocol* which when implemented allows a JavaScript object to define\n * their iteration behavior, such as what values are looped over in a\n * [`for...of`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of)\n * loop or `iterall`'s `forEach` function. Many [built-in types](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#Builtin_iterables)\n * implement the Iterable protocol, including `Array` and `Map`.\n *\n * While described by the [ES2015 version of JavaScript](http://www.ecma-international.org/ecma-262/6.0/#sec-iterable-interface)\n * it can be utilized by any version of JavaScript.\n *\n * @external Iterable\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#iterable|MDN Iteration protocols}\n */\n\n// In ES2015 environments, Symbol exists\nvar SYMBOL /*: any */ = typeof Symbol === 'function' ? Symbol : void 0\n\n// In ES2015 (or a polyfilled) environment, this will be Symbol.iterator\nvar SYMBOL_ITERATOR = SYMBOL && SYMBOL.iterator\n\n/**\n * A property name to be used as the name of an Iterable's method responsible\n * for producing an Iterator, referred to as `@@iterator`. Typically represents\n * the value `Symbol.iterator` but falls back to the string `\"@@iterator\"` when\n * `Symbol.iterator` is not defined.\n *\n * Use `$$iterator` for defining new Iterables instead of `Symbol.iterator`,\n * but do not use it for accessing existing Iterables, instead use\n * {@link getIterator} or {@link isIterable}.\n *\n * @example\n *\n * var $$iterator = require('iterall').$$iterator\n *\n * function Counter (to) {\n *   this.to = to\n * }\n *\n * Counter.prototype[$$iterator] = function () {\n *   return {\n *     to: this.to,\n *     num: 0,\n *     next () {\n *       if (this.num >= this.to) {\n *         return { value: undefined, done: true }\n *       }\n *       return { value: this.num++, done: false }\n *     }\n *   }\n * }\n *\n * var counter = new Counter(3)\n * for (var number of counter) {\n *   console.log(number) // 0 ... 1 ... 2\n * }\n *\n * @type {Symbol|string}\n */\n/*:: declare export var $$iterator: '@@iterator'; */\nvar $$iterator = SYMBOL_ITERATOR || '@@iterator'\n\n/**\n * Returns true if the provided object implements the Iterator protocol via\n * either implementing a `Symbol.iterator` or `\"@@iterator\"` method.\n *\n * @example\n *\n * var isIterable = require('iterall').isIterable\n * isIterable([ 1, 2, 3 ]) // true\n * isIterable('ABC') // true\n * isIterable({ length: 1, 0: 'Alpha' }) // false\n * isIterable({ key: 'value' }) // false\n * isIterable(new Map()) // true\n *\n * @param obj\n *   A value which might implement the Iterable protocol.\n * @return {boolean} true if Iterable.\n */\n/*:: declare export function isIterable(obj: any): boolean; */\nfunction isIterable(obj) {\n  return !!getIteratorMethod(obj)\n}\n\n/**\n * Returns true if the provided object implements the Array-like protocol via\n * defining a positive-integer `length` property.\n *\n * @example\n *\n * var isArrayLike = require('iterall').isArrayLike\n * isArrayLike([ 1, 2, 3 ]) // true\n * isArrayLike('ABC') // true\n * isArrayLike({ length: 1, 0: 'Alpha' }) // true\n * isArrayLike({ key: 'value' }) // false\n * isArrayLike(new Map()) // false\n *\n * @param obj\n *   A value which might implement the Array-like protocol.\n * @return {boolean} true if Array-like.\n */\n/*:: declare export function isArrayLike(obj: any): boolean; */\nfunction isArrayLike(obj) {\n  var length = obj != null && obj.length\n  return typeof length === 'number' && length >= 0 && length % 1 === 0\n}\n\n/**\n * Returns true if the provided object is an Object (i.e. not a string literal)\n * and is either Iterable or Array-like.\n *\n * This may be used in place of [Array.isArray()][isArray] to determine if an\n * object should be iterated-over. It always excludes string literals and\n * includes Arrays (regardless of if it is Iterable). It also includes other\n * Array-like objects such as NodeList, TypedArray, and Buffer.\n *\n * @example\n *\n * var isCollection = require('iterall').isCollection\n * isCollection([ 1, 2, 3 ]) // true\n * isCollection('ABC') // false\n * isCollection({ length: 1, 0: 'Alpha' }) // true\n * isCollection({ key: 'value' }) // false\n * isCollection(new Map()) // true\n *\n * @example\n *\n * var forEach = require('iterall').forEach\n * if (isCollection(obj)) {\n *   forEach(obj, function (value) {\n *     console.log(value)\n *   })\n * }\n *\n * @param obj\n *   An Object value which might implement the Iterable or Array-like protocols.\n * @return {boolean} true if Iterable or Array-like Object.\n */\n/*:: declare export function isCollection(obj: any): boolean; */\nfunction isCollection(obj) {\n  return Object(obj) === obj && (isArrayLike(obj) || isIterable(obj))\n}\n\n/**\n * If the provided object implements the Iterator protocol, its Iterator object\n * is returned. Otherwise returns undefined.\n *\n * @example\n *\n * var getIterator = require('iterall').getIterator\n * var iterator = getIterator([ 1, 2, 3 ])\n * iterator.next() // { value: 1, done: false }\n * iterator.next() // { value: 2, done: false }\n * iterator.next() // { value: 3, done: false }\n * iterator.next() // { value: undefined, done: true }\n *\n * @template T the type of each iterated value\n * @param {Iterable<T>} iterable\n *   An Iterable object which is the source of an Iterator.\n * @return {Iterator<T>} new Iterator instance.\n */\n/*:: declare export var getIterator:\n  & (<+TValue>(iterable: Iterable<TValue>) => Iterator<TValue>)\n  & ((iterable: mixed) => void | Iterator<mixed>); */\nfunction getIterator(iterable) {\n  var method = getIteratorMethod(iterable)\n  if (method) {\n    return method.call(iterable)\n  }\n}\n\n/**\n * If the provided object implements the Iterator protocol, the method\n * responsible for producing its Iterator object is returned.\n *\n * This is used in rare cases for performance tuning. This method must be called\n * with obj as the contextual this-argument.\n *\n * @example\n *\n * var getIteratorMethod = require('iterall').getIteratorMethod\n * var myArray = [ 1, 2, 3 ]\n * var method = getIteratorMethod(myArray)\n * if (method) {\n *   var iterator = method.call(myArray)\n * }\n *\n * @template T the type of each iterated value\n * @param {Iterable<T>} iterable\n *   An Iterable object which defines an `@@iterator` method.\n * @return {function(): Iterator<T>} `@@iterator` method.\n */\n/*:: declare export var getIteratorMethod:\n  & (<+TValue>(iterable: Iterable<TValue>) => (() => Iterator<TValue>))\n  & ((iterable: mixed) => (void | (() => Iterator<mixed>))); */\nfunction getIteratorMethod(iterable) {\n  if (iterable != null) {\n    var method =\n      (SYMBOL_ITERATOR && iterable[SYMBOL_ITERATOR]) || iterable['@@iterator']\n    if (typeof method === 'function') {\n      return method\n    }\n  }\n}\n\n/**\n * Similar to {@link getIterator}, this method returns a new Iterator given an\n * Iterable. However it will also create an Iterator for a non-Iterable\n * Array-like collection, such as Array in a non-ES2015 environment.\n *\n * `createIterator` is complimentary to `forEach`, but allows a \"pull\"-based\n * iteration as opposed to `forEach`'s \"push\"-based iteration.\n *\n * `createIterator` produces an Iterator for Array-likes with the same behavior\n * as ArrayIteratorPrototype described in the ECMAScript specification, and\n * does *not* skip over \"holes\".\n *\n * @example\n *\n * var createIterator = require('iterall').createIterator\n *\n * var myArraylike = { length: 3, 0: 'Alpha', 1: 'Bravo', 2: 'Charlie' }\n * var iterator = createIterator(myArraylike)\n * iterator.next() // { value: 'Alpha', done: false }\n * iterator.next() // { value: 'Bravo', done: false }\n * iterator.next() // { value: 'Charlie', done: false }\n * iterator.next() // { value: undefined, done: true }\n *\n * @template T the type of each iterated value\n * @param {Iterable<T>|{ length: number }} collection\n *   An Iterable or Array-like object to produce an Iterator.\n * @return {Iterator<T>} new Iterator instance.\n */\n/*:: declare export var createIterator:\n  & (<+TValue>(collection: Iterable<TValue>) => Iterator<TValue>)\n  & ((collection: {length: number}) => Iterator<mixed>)\n  & ((collection: mixed) => (void | Iterator<mixed>)); */\nfunction createIterator(collection) {\n  if (collection != null) {\n    var iterator = getIterator(collection)\n    if (iterator) {\n      return iterator\n    }\n    if (isArrayLike(collection)) {\n      return new ArrayLikeIterator(collection)\n    }\n  }\n}\n\n// When the object provided to `createIterator` is not Iterable but is\n// Array-like, this simple Iterator is created.\nfunction ArrayLikeIterator(obj) {\n  this._o = obj\n  this._i = 0\n}\n\n// Note: all Iterators are themselves Iterable.\nArrayLikeIterator.prototype[$$iterator] = function() {\n  return this\n}\n\n// A simple state-machine determines the IteratorResult returned, yielding\n// each value in the Array-like object in order of their indicies.\nArrayLikeIterator.prototype.next = function() {\n  if (this._o === void 0 || this._i >= this._o.length) {\n    this._o = void 0\n    return { value: void 0, done: true }\n  }\n  return { value: this._o[this._i++], done: false }\n}\n\n/**\n * Given an object which either implements the Iterable protocol or is\n * Array-like, iterate over it, calling the `callback` at each iteration.\n *\n * Use `forEach` where you would expect to use a `for ... of` loop in ES6.\n * However `forEach` adheres to the behavior of [Array#forEach][] described in\n * the ECMAScript specification, skipping over \"holes\" in Array-likes. It will\n * also delegate to a `forEach` method on `collection` if one is defined,\n * ensuring native performance for `Arrays`.\n *\n * Similar to [Array#forEach][], the `callback` function accepts three\n * arguments, and is provided with `thisArg` as the calling context.\n *\n * Note: providing an infinite Iterator to forEach will produce an error.\n *\n * [Array#forEach]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach\n *\n * @example\n *\n * var forEach = require('iterall').forEach\n *\n * forEach(myIterable, function (value, index, iterable) {\n *   console.log(value, index, iterable === myIterable)\n * })\n *\n * @example\n *\n * // ES6:\n * for (let value of myIterable) {\n *   console.log(value)\n * }\n *\n * // Any JavaScript environment:\n * forEach(myIterable, function (value) {\n *   console.log(value)\n * })\n *\n * @template T the type of each iterated value\n * @param {Iterable<T>|{ length: number }} collection\n *   The Iterable or array to iterate over.\n * @param {function(T, number, object)} callback\n *   Function to execute for each iteration, taking up to three arguments\n * @param [thisArg]\n *   Optional. Value to use as `this` when executing `callback`.\n */\n/*:: declare export var forEach:\n  & (<+TValue, TCollection: Iterable<TValue>>(\n      collection: TCollection,\n      callbackFn: (value: TValue, index: number, collection: TCollection) => any,\n      thisArg?: any\n    ) => void)\n  & (<TCollection: {length: number}>(\n      collection: TCollection,\n      callbackFn: (value: mixed, index: number, collection: TCollection) => any,\n      thisArg?: any\n    ) => void); */\nfunction forEach(collection, callback, thisArg) {\n  if (collection != null) {\n    if (typeof collection.forEach === 'function') {\n      return collection.forEach(callback, thisArg)\n    }\n    var i = 0\n    var iterator = getIterator(collection)\n    if (iterator) {\n      var step\n      while (!(step = iterator.next()).done) {\n        callback.call(thisArg, step.value, i++, collection)\n        // Infinite Iterators could cause forEach to run forever.\n        // After a very large number of iterations, produce an error.\n        /* istanbul ignore if */\n        if (i > 9999999) {\n          throw new TypeError('Near-infinite iteration.')\n        }\n      }\n    } else if (isArrayLike(collection)) {\n      for (; i < collection.length; i++) {\n        if (collection.hasOwnProperty(i)) {\n          callback.call(thisArg, collection[i], i, collection)\n        }\n      }\n    }\n  }\n}\n\n/////////////////////////////////////////////////////\n//                                                 //\n//                 ASYNC ITERATORS                 //\n//                                                 //\n/////////////////////////////////////////////////////\n\n/**\n * [AsyncIterable](https://tc39.github.io/proposal-async-iteration/#sec-asynciterable-interface)\n * is a *protocol* which when implemented allows a JavaScript object to define\n * an asynchronous iteration behavior, such as what values are looped over in\n * a [`for-await-of`](https://tc39.github.io/proposal-async-iteration/#sec-for-in-and-for-of-statements)\n * loop or `iterall`'s {@link forAwaitEach} function.\n *\n * While described as a proposed addition to the [ES2017 version of JavaScript](https://tc39.github.io/proposal-async-iteration/)\n * it can be utilized by any version of JavaScript.\n *\n * @external AsyncIterable\n * @see {@link https://tc39.github.io/proposal-async-iteration/#sec-asynciterable-interface|Async Iteration Proposal}\n * @template T The type of each iterated value\n * @property {function (): AsyncIterator<T>} Symbol.asyncIterator\n *   A method which produces an AsyncIterator for this AsyncIterable.\n */\n\n/**\n * [AsyncIterator](https://tc39.github.io/proposal-async-iteration/#sec-asynciterator-interface)\n * is a *protocol* which describes a standard way to produce and consume an\n * asynchronous sequence of values, typically the values of the\n * {@link AsyncIterable} represented by this {@link AsyncIterator}.\n *\n * AsyncIterator is similar to Observable or Stream. Like an {@link Iterator} it\n * also as a `next()` method, however instead of an IteratorResult,\n * calling this method returns a {@link Promise} for a IteratorResult.\n *\n * While described as a proposed addition to the [ES2017 version of JavaScript](https://tc39.github.io/proposal-async-iteration/)\n * it can be utilized by any version of JavaScript.\n *\n * @external AsyncIterator\n * @see {@link https://tc39.github.io/proposal-async-iteration/#sec-asynciterator-interface|Async Iteration Proposal}\n */\n\n// In ES2017 (or a polyfilled) environment, this will be Symbol.asyncIterator\nvar SYMBOL_ASYNC_ITERATOR = SYMBOL && SYMBOL.asyncIterator\n\n/**\n * A property name to be used as the name of an AsyncIterable's method\n * responsible for producing an Iterator, referred to as `@@asyncIterator`.\n * Typically represents the value `Symbol.asyncIterator` but falls back to the\n * string `\"@@asyncIterator\"` when `Symbol.asyncIterator` is not defined.\n *\n * Use `$$asyncIterator` for defining new AsyncIterables instead of\n * `Symbol.asyncIterator`, but do not use it for accessing existing Iterables,\n * instead use {@link getAsyncIterator} or {@link isAsyncIterable}.\n *\n * @example\n *\n * var $$asyncIterator = require('iterall').$$asyncIterator\n *\n * function Chirper (to) {\n *   this.to = to\n * }\n *\n * Chirper.prototype[$$asyncIterator] = function () {\n *   return {\n *     to: this.to,\n *     num: 0,\n *     next () {\n *       return new Promise(resolve => {\n *         if (this.num >= this.to) {\n *           resolve({ value: undefined, done: true })\n *         } else {\n *           setTimeout(() => {\n *             resolve({ value: this.num++, done: false })\n *           }, 1000)\n *         }\n *       })\n *     }\n *   }\n * }\n *\n * var chirper = new Chirper(3)\n * for await (var number of chirper) {\n *   console.log(number) // 0 ...wait... 1 ...wait... 2\n * }\n *\n * @type {Symbol|string}\n */\n/*:: declare export var $$asyncIterator: '@@asyncIterator'; */\nvar $$asyncIterator = SYMBOL_ASYNC_ITERATOR || '@@asyncIterator'\n\n/**\n * Returns true if the provided object implements the AsyncIterator protocol via\n * either implementing a `Symbol.asyncIterator` or `\"@@asyncIterator\"` method.\n *\n * @example\n *\n * var isAsyncIterable = require('iterall').isAsyncIterable\n * isAsyncIterable(myStream) // true\n * isAsyncIterable('ABC') // false\n *\n * @param obj\n *   A value which might implement the AsyncIterable protocol.\n * @return {boolean} true if AsyncIterable.\n */\n/*:: declare export function isAsyncIterable(obj: any): boolean; */\nfunction isAsyncIterable(obj) {\n  return !!getAsyncIteratorMethod(obj)\n}\n\n/**\n * If the provided object implements the AsyncIterator protocol, its\n * AsyncIterator object is returned. Otherwise returns undefined.\n *\n * @example\n *\n * var getAsyncIterator = require('iterall').getAsyncIterator\n * var asyncIterator = getAsyncIterator(myStream)\n * asyncIterator.next().then(console.log) // { value: 1, done: false }\n * asyncIterator.next().then(console.log) // { value: 2, done: false }\n * asyncIterator.next().then(console.log) // { value: 3, done: false }\n * asyncIterator.next().then(console.log) // { value: undefined, done: true }\n *\n * @template T the type of each iterated value\n * @param {AsyncIterable<T>} asyncIterable\n *   An AsyncIterable object which is the source of an AsyncIterator.\n * @return {AsyncIterator<T>} new AsyncIterator instance.\n */\n/*:: declare export var getAsyncIterator:\n  & (<+TValue>(asyncIterable: AsyncIterable<TValue>) => AsyncIterator<TValue>)\n  & ((asyncIterable: mixed) => (void | AsyncIterator<mixed>)); */\nfunction getAsyncIterator(asyncIterable) {\n  var method = getAsyncIteratorMethod(asyncIterable)\n  if (method) {\n    return method.call(asyncIterable)\n  }\n}\n\n/**\n * If the provided object implements the AsyncIterator protocol, the method\n * responsible for producing its AsyncIterator object is returned.\n *\n * This is used in rare cases for performance tuning. This method must be called\n * with obj as the contextual this-argument.\n *\n * @example\n *\n * var getAsyncIteratorMethod = require('iterall').getAsyncIteratorMethod\n * var method = getAsyncIteratorMethod(myStream)\n * if (method) {\n *   var asyncIterator = method.call(myStream)\n * }\n *\n * @template T the type of each iterated value\n * @param {AsyncIterable<T>} asyncIterable\n *   An AsyncIterable object which defines an `@@asyncIterator` method.\n * @return {function(): AsyncIterator<T>} `@@asyncIterator` method.\n */\n/*:: declare export var getAsyncIteratorMethod:\n  & (<+TValue>(asyncIterable: AsyncIterable<TValue>) => (() => AsyncIterator<TValue>))\n  & ((asyncIterable: mixed) => (void | (() => AsyncIterator<mixed>))); */\nfunction getAsyncIteratorMethod(asyncIterable) {\n  if (asyncIterable != null) {\n    var method =\n      (SYMBOL_ASYNC_ITERATOR && asyncIterable[SYMBOL_ASYNC_ITERATOR]) ||\n      asyncIterable['@@asyncIterator']\n    if (typeof method === 'function') {\n      return method\n    }\n  }\n}\n\n/**\n * Similar to {@link getAsyncIterator}, this method returns a new AsyncIterator\n * given an AsyncIterable. However it will also create an AsyncIterator for a\n * non-async Iterable as well as non-Iterable Array-like collection, such as\n * Array in a pre-ES2015 environment.\n *\n * `createAsyncIterator` is complimentary to `forAwaitEach`, but allows a\n * buffering \"pull\"-based iteration as opposed to `forAwaitEach`'s\n * \"push\"-based iteration.\n *\n * `createAsyncIterator` produces an AsyncIterator for non-async Iterables as\n * described in the ECMAScript proposal [Async-from-Sync Iterator Objects](https://tc39.github.io/proposal-async-iteration/#sec-async-from-sync-iterator-objects).\n *\n * > Note: Creating `AsyncIterator`s requires the existence of `Promise`.\n * > While `Promise` has been available in modern browsers for a number of\n * > years, legacy browsers (like IE 11) may require a polyfill.\n *\n * @example\n *\n * var createAsyncIterator = require('iterall').createAsyncIterator\n *\n * var myArraylike = { length: 3, 0: 'Alpha', 1: 'Bravo', 2: 'Charlie' }\n * var iterator = createAsyncIterator(myArraylike)\n * iterator.next().then(console.log) // { value: 'Alpha', done: false }\n * iterator.next().then(console.log) // { value: 'Bravo', done: false }\n * iterator.next().then(console.log) // { value: 'Charlie', done: false }\n * iterator.next().then(console.log) // { value: undefined, done: true }\n *\n * @template T the type of each iterated value\n * @param {AsyncIterable<T>|Iterable<T>|{ length: number }} source\n *   An AsyncIterable, Iterable, or Array-like object to produce an Iterator.\n * @return {AsyncIterator<T>} new AsyncIterator instance.\n */\n/*:: declare export var createAsyncIterator:\n  & (<+TValue>(\n      collection: Iterable<Promise<TValue> | TValue> | AsyncIterable<TValue>\n    ) => AsyncIterator<TValue>)\n  & ((collection: {length: number}) => AsyncIterator<mixed>)\n  & ((collection: mixed) => (void | AsyncIterator<mixed>)); */\nfunction createAsyncIterator(source) {\n  if (source != null) {\n    var asyncIterator = getAsyncIterator(source)\n    if (asyncIterator) {\n      return asyncIterator\n    }\n    var iterator = createIterator(source)\n    if (iterator) {\n      return new AsyncFromSyncIterator(iterator)\n    }\n  }\n}\n\n// When the object provided to `createAsyncIterator` is not AsyncIterable but is\n// sync Iterable, this simple wrapper is created.\nfunction AsyncFromSyncIterator(iterator) {\n  this._i = iterator\n}\n\n// Note: all AsyncIterators are themselves AsyncIterable.\nAsyncFromSyncIterator.prototype[$$asyncIterator] = function() {\n  return this\n}\n\n// A simple state-machine determines the IteratorResult returned, yielding\n// each value in the Array-like object in order of their indicies.\nAsyncFromSyncIterator.prototype.next = function(value) {\n  return unwrapAsyncFromSync(this._i, 'next', value)\n}\n\nAsyncFromSyncIterator.prototype.return = function(value) {\n  return this._i.return\n    ? unwrapAsyncFromSync(this._i, 'return', value)\n    : Promise.resolve({ value: value, done: true })\n}\n\nAsyncFromSyncIterator.prototype.throw = function(value) {\n  return this._i.throw\n    ? unwrapAsyncFromSync(this._i, 'throw', value)\n    : Promise.reject(value)\n}\n\nfunction unwrapAsyncFromSync(iterator, fn, value) {\n  var step\n  return new Promise(function(resolve) {\n    step = iterator[fn](value)\n    resolve(step.value)\n  }).then(function(value) {\n    return { value: value, done: step.done }\n  })\n}\n\n/**\n * Given an object which either implements the AsyncIterable protocol or is\n * Array-like, iterate over it, calling the `callback` at each iteration.\n *\n * Use `forAwaitEach` where you would expect to use a [for-await-of](https://tc39.github.io/proposal-async-iteration/#sec-for-in-and-for-of-statements) loop.\n *\n * Similar to [Array#forEach][], the `callback` function accepts three\n * arguments, and is provided with `thisArg` as the calling context.\n *\n * > Note: Using `forAwaitEach` requires the existence of `Promise`.\n * > While `Promise` has been available in modern browsers for a number of\n * > years, legacy browsers (like IE 11) may require a polyfill.\n *\n * @example\n *\n * var forAwaitEach = require('iterall').forAwaitEach\n *\n * forAwaitEach(myIterable, function (value, index, iterable) {\n *   console.log(value, index, iterable === myIterable)\n * })\n *\n * @example\n *\n * // ES2017:\n * for await (let value of myAsyncIterable) {\n *   console.log(await doSomethingAsync(value))\n * }\n * console.log('done')\n *\n * // Any JavaScript environment:\n * forAwaitEach(myAsyncIterable, function (value) {\n *   return doSomethingAsync(value).then(console.log)\n * }).then(function () {\n *   console.log('done')\n * })\n *\n * @template T the type of each iterated value\n * @param {AsyncIterable<T>|Iterable<Promise<T> | T>|{ length: number }} source\n *   The AsyncIterable or array to iterate over.\n * @param {function(T, number, object)} callback\n *   Function to execute for each iteration, taking up to three arguments\n * @param [thisArg]\n *   Optional. Value to use as `this` when executing `callback`.\n */\n/*:: declare export var forAwaitEach:\n  & (<+TValue, TCollection: Iterable<Promise<TValue> | TValue> | AsyncIterable<TValue>>(\n      collection: TCollection,\n      callbackFn: (value: TValue, index: number, collection: TCollection) => any,\n      thisArg?: any\n    ) => Promise<void>)\n  & (<TCollection: { length: number }>(\n      collection: TCollection,\n      callbackFn: (value: mixed, index: number, collection: TCollection) => any,\n      thisArg?: any\n    ) => Promise<void>); */\nfunction forAwaitEach(source, callback, thisArg) {\n  var asyncIterator = createAsyncIterator(source)\n  if (asyncIterator) {\n    var i = 0\n    return new Promise(function(resolve, reject) {\n      function next() {\n        asyncIterator\n          .next()\n          .then(function(step) {\n            if (!step.done) {\n              Promise.resolve(callback.call(thisArg, step.value, i++, source))\n                .then(next)\n                .catch(reject)\n            } else {\n              resolve()\n            }\n            // Explicitly return null, silencing bluebird-style warnings.\n            return null\n          })\n          .catch(reject)\n        // Explicitly return null, silencing bluebird-style warnings.\n        return null\n      }\n      next()\n    })\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lbmF0ZWdhLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2l0ZXJhbGwvaW5kZXgubWpzP2ZkZjAiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYsIExlZSBCeXJvblxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAZmxvd1xuICogQGlnbm9yZVxuICovXG5cbi8qKlxuICogW0l0ZXJhdG9yXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9JdGVyYXRpb25fcHJvdG9jb2xzI2l0ZXJhdG9yKVxuICogaXMgYSAqcHJvdG9jb2wqIHdoaWNoIGRlc2NyaWJlcyBhIHN0YW5kYXJkIHdheSB0byBwcm9kdWNlIGEgc2VxdWVuY2Ugb2ZcbiAqIHZhbHVlcywgdHlwaWNhbGx5IHRoZSB2YWx1ZXMgb2YgdGhlIEl0ZXJhYmxlIHJlcHJlc2VudGVkIGJ5IHRoaXMgSXRlcmF0b3IuXG4gKlxuICogV2hpbGUgZGVzY3JpYmVkIGJ5IHRoZSBbRVMyMDE1IHZlcnNpb24gb2YgSmF2YVNjcmlwdF0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLWl0ZXJhdG9yLWludGVyZmFjZSlcbiAqIGl0IGNhbiBiZSB1dGlsaXplZCBieSBhbnkgdmVyc2lvbiBvZiBKYXZhU2NyaXB0LlxuICpcbiAqIEBleHRlcm5hbCBJdGVyYXRvclxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvSXRlcmF0aW9uX3Byb3RvY29scyNpdGVyYXRvcnxNRE4gSXRlcmF0aW9uIHByb3RvY29sc31cbiAqL1xuXG4vKipcbiAqIFtJdGVyYWJsZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvSXRlcmF0aW9uX3Byb3RvY29scyNpdGVyYWJsZSlcbiAqIGlzIGEgKnByb3RvY29sKiB3aGljaCB3aGVuIGltcGxlbWVudGVkIGFsbG93cyBhIEphdmFTY3JpcHQgb2JqZWN0IHRvIGRlZmluZVxuICogdGhlaXIgaXRlcmF0aW9uIGJlaGF2aW9yLCBzdWNoIGFzIHdoYXQgdmFsdWVzIGFyZSBsb29wZWQgb3ZlciBpbiBhXG4gKiBbYGZvci4uLm9mYF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvU3RhdGVtZW50cy9mb3IuLi5vZilcbiAqIGxvb3Agb3IgYGl0ZXJhbGxgJ3MgYGZvckVhY2hgIGZ1bmN0aW9uLiBNYW55IFtidWlsdC1pbiB0eXBlc10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvSXRlcmF0aW9uX3Byb3RvY29scyNCdWlsdGluX2l0ZXJhYmxlcylcbiAqIGltcGxlbWVudCB0aGUgSXRlcmFibGUgcHJvdG9jb2wsIGluY2x1ZGluZyBgQXJyYXlgIGFuZCBgTWFwYC5cbiAqXG4gKiBXaGlsZSBkZXNjcmliZWQgYnkgdGhlIFtFUzIwMTUgdmVyc2lvbiBvZiBKYXZhU2NyaXB0XShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtaXRlcmFibGUtaW50ZXJmYWNlKVxuICogaXQgY2FuIGJlIHV0aWxpemVkIGJ5IGFueSB2ZXJzaW9uIG9mIEphdmFTY3JpcHQuXG4gKlxuICogQGV4dGVybmFsIEl0ZXJhYmxlXG4gKiBAc2VlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9JdGVyYXRpb25fcHJvdG9jb2xzI2l0ZXJhYmxlfE1ETiBJdGVyYXRpb24gcHJvdG9jb2xzfVxuICovXG5cbi8vIEluIEVTMjAxNSBlbnZpcm9ubWVudHMsIFN5bWJvbCBleGlzdHNcbnZhciBTWU1CT0wgLyo6IGFueSAqLyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgPyBTeW1ib2wgOiB2b2lkIDBcblxuLy8gSW4gRVMyMDE1IChvciBhIHBvbHlmaWxsZWQpIGVudmlyb25tZW50LCB0aGlzIHdpbGwgYmUgU3ltYm9sLml0ZXJhdG9yXG52YXIgU1lNQk9MX0lURVJBVE9SID0gU1lNQk9MICYmIFNZTUJPTC5pdGVyYXRvclxuXG4vKipcbiAqIEEgcHJvcGVydHkgbmFtZSB0byBiZSB1c2VkIGFzIHRoZSBuYW1lIG9mIGFuIEl0ZXJhYmxlJ3MgbWV0aG9kIHJlc3BvbnNpYmxlXG4gKiBmb3IgcHJvZHVjaW5nIGFuIEl0ZXJhdG9yLCByZWZlcnJlZCB0byBhcyBgQEBpdGVyYXRvcmAuIFR5cGljYWxseSByZXByZXNlbnRzXG4gKiB0aGUgdmFsdWUgYFN5bWJvbC5pdGVyYXRvcmAgYnV0IGZhbGxzIGJhY2sgdG8gdGhlIHN0cmluZyBgXCJAQGl0ZXJhdG9yXCJgIHdoZW5cbiAqIGBTeW1ib2wuaXRlcmF0b3JgIGlzIG5vdCBkZWZpbmVkLlxuICpcbiAqIFVzZSBgJCRpdGVyYXRvcmAgZm9yIGRlZmluaW5nIG5ldyBJdGVyYWJsZXMgaW5zdGVhZCBvZiBgU3ltYm9sLml0ZXJhdG9yYCxcbiAqIGJ1dCBkbyBub3QgdXNlIGl0IGZvciBhY2Nlc3NpbmcgZXhpc3RpbmcgSXRlcmFibGVzLCBpbnN0ZWFkIHVzZVxuICoge0BsaW5rIGdldEl0ZXJhdG9yfSBvciB7QGxpbmsgaXNJdGVyYWJsZX0uXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgJCRpdGVyYXRvciA9IHJlcXVpcmUoJ2l0ZXJhbGwnKS4kJGl0ZXJhdG9yXG4gKlxuICogZnVuY3Rpb24gQ291bnRlciAodG8pIHtcbiAqICAgdGhpcy50byA9IHRvXG4gKiB9XG4gKlxuICogQ291bnRlci5wcm90b3R5cGVbJCRpdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7XG4gKiAgIHJldHVybiB7XG4gKiAgICAgdG86IHRoaXMudG8sXG4gKiAgICAgbnVtOiAwLFxuICogICAgIG5leHQgKCkge1xuICogICAgICAgaWYgKHRoaXMubnVtID49IHRoaXMudG8pIHtcbiAqICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9XG4gKiAgICAgICB9XG4gKiAgICAgICByZXR1cm4geyB2YWx1ZTogdGhpcy5udW0rKywgZG9uZTogZmFsc2UgfVxuICogICAgIH1cbiAqICAgfVxuICogfVxuICpcbiAqIHZhciBjb3VudGVyID0gbmV3IENvdW50ZXIoMylcbiAqIGZvciAodmFyIG51bWJlciBvZiBjb3VudGVyKSB7XG4gKiAgIGNvbnNvbGUubG9nKG51bWJlcikgLy8gMCAuLi4gMSAuLi4gMlxuICogfVxuICpcbiAqIEB0eXBlIHtTeW1ib2x8c3RyaW5nfVxuICovXG4vKjo6IGRlY2xhcmUgZXhwb3J0IHZhciAkJGl0ZXJhdG9yOiAnQEBpdGVyYXRvcic7ICovXG5leHBvcnQgdmFyICQkaXRlcmF0b3IgPSBTWU1CT0xfSVRFUkFUT1IgfHwgJ0BAaXRlcmF0b3InXG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBwcm92aWRlZCBvYmplY3QgaW1wbGVtZW50cyB0aGUgSXRlcmF0b3IgcHJvdG9jb2wgdmlhXG4gKiBlaXRoZXIgaW1wbGVtZW50aW5nIGEgYFN5bWJvbC5pdGVyYXRvcmAgb3IgYFwiQEBpdGVyYXRvclwiYCBtZXRob2QuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgaXNJdGVyYWJsZSA9IHJlcXVpcmUoJ2l0ZXJhbGwnKS5pc0l0ZXJhYmxlXG4gKiBpc0l0ZXJhYmxlKFsgMSwgMiwgMyBdKSAvLyB0cnVlXG4gKiBpc0l0ZXJhYmxlKCdBQkMnKSAvLyB0cnVlXG4gKiBpc0l0ZXJhYmxlKHsgbGVuZ3RoOiAxLCAwOiAnQWxwaGEnIH0pIC8vIGZhbHNlXG4gKiBpc0l0ZXJhYmxlKHsga2V5OiAndmFsdWUnIH0pIC8vIGZhbHNlXG4gKiBpc0l0ZXJhYmxlKG5ldyBNYXAoKSkgLy8gdHJ1ZVxuICpcbiAqIEBwYXJhbSBvYmpcbiAqICAgQSB2YWx1ZSB3aGljaCBtaWdodCBpbXBsZW1lbnQgdGhlIEl0ZXJhYmxlIHByb3RvY29sLlxuICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiBJdGVyYWJsZS5cbiAqL1xuLyo6OiBkZWNsYXJlIGV4cG9ydCBmdW5jdGlvbiBpc0l0ZXJhYmxlKG9iajogYW55KTogYm9vbGVhbjsgKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0l0ZXJhYmxlKG9iaikge1xuICByZXR1cm4gISFnZXRJdGVyYXRvck1ldGhvZChvYmopXG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBwcm92aWRlZCBvYmplY3QgaW1wbGVtZW50cyB0aGUgQXJyYXktbGlrZSBwcm90b2NvbCB2aWFcbiAqIGRlZmluaW5nIGEgcG9zaXRpdmUtaW50ZWdlciBgbGVuZ3RoYCBwcm9wZXJ0eS5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBpc0FycmF5TGlrZSA9IHJlcXVpcmUoJ2l0ZXJhbGwnKS5pc0FycmF5TGlrZVxuICogaXNBcnJheUxpa2UoWyAxLCAyLCAzIF0pIC8vIHRydWVcbiAqIGlzQXJyYXlMaWtlKCdBQkMnKSAvLyB0cnVlXG4gKiBpc0FycmF5TGlrZSh7IGxlbmd0aDogMSwgMDogJ0FscGhhJyB9KSAvLyB0cnVlXG4gKiBpc0FycmF5TGlrZSh7IGtleTogJ3ZhbHVlJyB9KSAvLyBmYWxzZVxuICogaXNBcnJheUxpa2UobmV3IE1hcCgpKSAvLyBmYWxzZVxuICpcbiAqIEBwYXJhbSBvYmpcbiAqICAgQSB2YWx1ZSB3aGljaCBtaWdodCBpbXBsZW1lbnQgdGhlIEFycmF5LWxpa2UgcHJvdG9jb2wuXG4gKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIEFycmF5LWxpa2UuXG4gKi9cbi8qOjogZGVjbGFyZSBleHBvcnQgZnVuY3Rpb24gaXNBcnJheUxpa2Uob2JqOiBhbnkpOiBib29sZWFuOyAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzQXJyYXlMaWtlKG9iaikge1xuICB2YXIgbGVuZ3RoID0gb2JqICE9IG51bGwgJiYgb2JqLmxlbmd0aFxuICByZXR1cm4gdHlwZW9mIGxlbmd0aCA9PT0gJ251bWJlcicgJiYgbGVuZ3RoID49IDAgJiYgbGVuZ3RoICUgMSA9PT0gMFxufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcHJvdmlkZWQgb2JqZWN0IGlzIGFuIE9iamVjdCAoaS5lLiBub3QgYSBzdHJpbmcgbGl0ZXJhbClcbiAqIGFuZCBpcyBlaXRoZXIgSXRlcmFibGUgb3IgQXJyYXktbGlrZS5cbiAqXG4gKiBUaGlzIG1heSBiZSB1c2VkIGluIHBsYWNlIG9mIFtBcnJheS5pc0FycmF5KCldW2lzQXJyYXldIHRvIGRldGVybWluZSBpZiBhblxuICogb2JqZWN0IHNob3VsZCBiZSBpdGVyYXRlZC1vdmVyLiBJdCBhbHdheXMgZXhjbHVkZXMgc3RyaW5nIGxpdGVyYWxzIGFuZFxuICogaW5jbHVkZXMgQXJyYXlzIChyZWdhcmRsZXNzIG9mIGlmIGl0IGlzIEl0ZXJhYmxlKS4gSXQgYWxzbyBpbmNsdWRlcyBvdGhlclxuICogQXJyYXktbGlrZSBvYmplY3RzIHN1Y2ggYXMgTm9kZUxpc3QsIFR5cGVkQXJyYXksIGFuZCBCdWZmZXIuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgaXNDb2xsZWN0aW9uID0gcmVxdWlyZSgnaXRlcmFsbCcpLmlzQ29sbGVjdGlvblxuICogaXNDb2xsZWN0aW9uKFsgMSwgMiwgMyBdKSAvLyB0cnVlXG4gKiBpc0NvbGxlY3Rpb24oJ0FCQycpIC8vIGZhbHNlXG4gKiBpc0NvbGxlY3Rpb24oeyBsZW5ndGg6IDEsIDA6ICdBbHBoYScgfSkgLy8gdHJ1ZVxuICogaXNDb2xsZWN0aW9uKHsga2V5OiAndmFsdWUnIH0pIC8vIGZhbHNlXG4gKiBpc0NvbGxlY3Rpb24obmV3IE1hcCgpKSAvLyB0cnVlXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgZm9yRWFjaCA9IHJlcXVpcmUoJ2l0ZXJhbGwnKS5mb3JFYWNoXG4gKiBpZiAoaXNDb2xsZWN0aW9uKG9iaikpIHtcbiAqICAgZm9yRWFjaChvYmosIGZ1bmN0aW9uICh2YWx1ZSkge1xuICogICAgIGNvbnNvbGUubG9nKHZhbHVlKVxuICogICB9KVxuICogfVxuICpcbiAqIEBwYXJhbSBvYmpcbiAqICAgQW4gT2JqZWN0IHZhbHVlIHdoaWNoIG1pZ2h0IGltcGxlbWVudCB0aGUgSXRlcmFibGUgb3IgQXJyYXktbGlrZSBwcm90b2NvbHMuXG4gKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIEl0ZXJhYmxlIG9yIEFycmF5LWxpa2UgT2JqZWN0LlxuICovXG4vKjo6IGRlY2xhcmUgZXhwb3J0IGZ1bmN0aW9uIGlzQ29sbGVjdGlvbihvYmo6IGFueSk6IGJvb2xlYW47ICovXG5leHBvcnQgZnVuY3Rpb24gaXNDb2xsZWN0aW9uKG9iaikge1xuICByZXR1cm4gT2JqZWN0KG9iaikgPT09IG9iaiAmJiAoaXNBcnJheUxpa2Uob2JqKSB8fCBpc0l0ZXJhYmxlKG9iaikpXG59XG5cbi8qKlxuICogSWYgdGhlIHByb3ZpZGVkIG9iamVjdCBpbXBsZW1lbnRzIHRoZSBJdGVyYXRvciBwcm90b2NvbCwgaXRzIEl0ZXJhdG9yIG9iamVjdFxuICogaXMgcmV0dXJuZWQuIE90aGVyd2lzZSByZXR1cm5zIHVuZGVmaW5lZC5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBnZXRJdGVyYXRvciA9IHJlcXVpcmUoJ2l0ZXJhbGwnKS5nZXRJdGVyYXRvclxuICogdmFyIGl0ZXJhdG9yID0gZ2V0SXRlcmF0b3IoWyAxLCAyLCAzIF0pXG4gKiBpdGVyYXRvci5uZXh0KCkgLy8geyB2YWx1ZTogMSwgZG9uZTogZmFsc2UgfVxuICogaXRlcmF0b3IubmV4dCgpIC8vIHsgdmFsdWU6IDIsIGRvbmU6IGZhbHNlIH1cbiAqIGl0ZXJhdG9yLm5leHQoKSAvLyB7IHZhbHVlOiAzLCBkb25lOiBmYWxzZSB9XG4gKiBpdGVyYXRvci5uZXh0KCkgLy8geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH1cbiAqXG4gKiBAdGVtcGxhdGUgVCB0aGUgdHlwZSBvZiBlYWNoIGl0ZXJhdGVkIHZhbHVlXG4gKiBAcGFyYW0ge0l0ZXJhYmxlPFQ+fSBpdGVyYWJsZVxuICogICBBbiBJdGVyYWJsZSBvYmplY3Qgd2hpY2ggaXMgdGhlIHNvdXJjZSBvZiBhbiBJdGVyYXRvci5cbiAqIEByZXR1cm4ge0l0ZXJhdG9yPFQ+fSBuZXcgSXRlcmF0b3IgaW5zdGFuY2UuXG4gKi9cbi8qOjogZGVjbGFyZSBleHBvcnQgdmFyIGdldEl0ZXJhdG9yOlxuICAmICg8K1RWYWx1ZT4oaXRlcmFibGU6IEl0ZXJhYmxlPFRWYWx1ZT4pID0+IEl0ZXJhdG9yPFRWYWx1ZT4pXG4gICYgKChpdGVyYWJsZTogbWl4ZWQpID0+IHZvaWQgfCBJdGVyYXRvcjxtaXhlZD4pOyAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEl0ZXJhdG9yKGl0ZXJhYmxlKSB7XG4gIHZhciBtZXRob2QgPSBnZXRJdGVyYXRvck1ldGhvZChpdGVyYWJsZSlcbiAgaWYgKG1ldGhvZCkge1xuICAgIHJldHVybiBtZXRob2QuY2FsbChpdGVyYWJsZSlcbiAgfVxufVxuXG4vKipcbiAqIElmIHRoZSBwcm92aWRlZCBvYmplY3QgaW1wbGVtZW50cyB0aGUgSXRlcmF0b3IgcHJvdG9jb2wsIHRoZSBtZXRob2RcbiAqIHJlc3BvbnNpYmxlIGZvciBwcm9kdWNpbmcgaXRzIEl0ZXJhdG9yIG9iamVjdCBpcyByZXR1cm5lZC5cbiAqXG4gKiBUaGlzIGlzIHVzZWQgaW4gcmFyZSBjYXNlcyBmb3IgcGVyZm9ybWFuY2UgdHVuaW5nLiBUaGlzIG1ldGhvZCBtdXN0IGJlIGNhbGxlZFxuICogd2l0aCBvYmogYXMgdGhlIGNvbnRleHR1YWwgdGhpcy1hcmd1bWVudC5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBnZXRJdGVyYXRvck1ldGhvZCA9IHJlcXVpcmUoJ2l0ZXJhbGwnKS5nZXRJdGVyYXRvck1ldGhvZFxuICogdmFyIG15QXJyYXkgPSBbIDEsIDIsIDMgXVxuICogdmFyIG1ldGhvZCA9IGdldEl0ZXJhdG9yTWV0aG9kKG15QXJyYXkpXG4gKiBpZiAobWV0aG9kKSB7XG4gKiAgIHZhciBpdGVyYXRvciA9IG1ldGhvZC5jYWxsKG15QXJyYXkpXG4gKiB9XG4gKlxuICogQHRlbXBsYXRlIFQgdGhlIHR5cGUgb2YgZWFjaCBpdGVyYXRlZCB2YWx1ZVxuICogQHBhcmFtIHtJdGVyYWJsZTxUPn0gaXRlcmFibGVcbiAqICAgQW4gSXRlcmFibGUgb2JqZWN0IHdoaWNoIGRlZmluZXMgYW4gYEBAaXRlcmF0b3JgIG1ldGhvZC5cbiAqIEByZXR1cm4ge2Z1bmN0aW9uKCk6IEl0ZXJhdG9yPFQ+fSBgQEBpdGVyYXRvcmAgbWV0aG9kLlxuICovXG4vKjo6IGRlY2xhcmUgZXhwb3J0IHZhciBnZXRJdGVyYXRvck1ldGhvZDpcbiAgJiAoPCtUVmFsdWU+KGl0ZXJhYmxlOiBJdGVyYWJsZTxUVmFsdWU+KSA9PiAoKCkgPT4gSXRlcmF0b3I8VFZhbHVlPikpXG4gICYgKChpdGVyYWJsZTogbWl4ZWQpID0+ICh2b2lkIHwgKCgpID0+IEl0ZXJhdG9yPG1peGVkPikpKTsgKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRJdGVyYXRvck1ldGhvZChpdGVyYWJsZSkge1xuICBpZiAoaXRlcmFibGUgIT0gbnVsbCkge1xuICAgIHZhciBtZXRob2QgPVxuICAgICAgKFNZTUJPTF9JVEVSQVRPUiAmJiBpdGVyYWJsZVtTWU1CT0xfSVRFUkFUT1JdKSB8fCBpdGVyYWJsZVsnQEBpdGVyYXRvciddXG4gICAgaWYgKHR5cGVvZiBtZXRob2QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBtZXRob2RcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBTaW1pbGFyIHRvIHtAbGluayBnZXRJdGVyYXRvcn0sIHRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgSXRlcmF0b3IgZ2l2ZW4gYW5cbiAqIEl0ZXJhYmxlLiBIb3dldmVyIGl0IHdpbGwgYWxzbyBjcmVhdGUgYW4gSXRlcmF0b3IgZm9yIGEgbm9uLUl0ZXJhYmxlXG4gKiBBcnJheS1saWtlIGNvbGxlY3Rpb24sIHN1Y2ggYXMgQXJyYXkgaW4gYSBub24tRVMyMDE1IGVudmlyb25tZW50LlxuICpcbiAqIGBjcmVhdGVJdGVyYXRvcmAgaXMgY29tcGxpbWVudGFyeSB0byBgZm9yRWFjaGAsIGJ1dCBhbGxvd3MgYSBcInB1bGxcIi1iYXNlZFxuICogaXRlcmF0aW9uIGFzIG9wcG9zZWQgdG8gYGZvckVhY2hgJ3MgXCJwdXNoXCItYmFzZWQgaXRlcmF0aW9uLlxuICpcbiAqIGBjcmVhdGVJdGVyYXRvcmAgcHJvZHVjZXMgYW4gSXRlcmF0b3IgZm9yIEFycmF5LWxpa2VzIHdpdGggdGhlIHNhbWUgYmVoYXZpb3JcbiAqIGFzIEFycmF5SXRlcmF0b3JQcm90b3R5cGUgZGVzY3JpYmVkIGluIHRoZSBFQ01BU2NyaXB0IHNwZWNpZmljYXRpb24sIGFuZFxuICogZG9lcyAqbm90KiBza2lwIG92ZXIgXCJob2xlc1wiLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIGNyZWF0ZUl0ZXJhdG9yID0gcmVxdWlyZSgnaXRlcmFsbCcpLmNyZWF0ZUl0ZXJhdG9yXG4gKlxuICogdmFyIG15QXJyYXlsaWtlID0geyBsZW5ndGg6IDMsIDA6ICdBbHBoYScsIDE6ICdCcmF2bycsIDI6ICdDaGFybGllJyB9XG4gKiB2YXIgaXRlcmF0b3IgPSBjcmVhdGVJdGVyYXRvcihteUFycmF5bGlrZSlcbiAqIGl0ZXJhdG9yLm5leHQoKSAvLyB7IHZhbHVlOiAnQWxwaGEnLCBkb25lOiBmYWxzZSB9XG4gKiBpdGVyYXRvci5uZXh0KCkgLy8geyB2YWx1ZTogJ0JyYXZvJywgZG9uZTogZmFsc2UgfVxuICogaXRlcmF0b3IubmV4dCgpIC8vIHsgdmFsdWU6ICdDaGFybGllJywgZG9uZTogZmFsc2UgfVxuICogaXRlcmF0b3IubmV4dCgpIC8vIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9XG4gKlxuICogQHRlbXBsYXRlIFQgdGhlIHR5cGUgb2YgZWFjaCBpdGVyYXRlZCB2YWx1ZVxuICogQHBhcmFtIHtJdGVyYWJsZTxUPnx7IGxlbmd0aDogbnVtYmVyIH19IGNvbGxlY3Rpb25cbiAqICAgQW4gSXRlcmFibGUgb3IgQXJyYXktbGlrZSBvYmplY3QgdG8gcHJvZHVjZSBhbiBJdGVyYXRvci5cbiAqIEByZXR1cm4ge0l0ZXJhdG9yPFQ+fSBuZXcgSXRlcmF0b3IgaW5zdGFuY2UuXG4gKi9cbi8qOjogZGVjbGFyZSBleHBvcnQgdmFyIGNyZWF0ZUl0ZXJhdG9yOlxuICAmICg8K1RWYWx1ZT4oY29sbGVjdGlvbjogSXRlcmFibGU8VFZhbHVlPikgPT4gSXRlcmF0b3I8VFZhbHVlPilcbiAgJiAoKGNvbGxlY3Rpb246IHtsZW5ndGg6IG51bWJlcn0pID0+IEl0ZXJhdG9yPG1peGVkPilcbiAgJiAoKGNvbGxlY3Rpb246IG1peGVkKSA9PiAodm9pZCB8IEl0ZXJhdG9yPG1peGVkPikpOyAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUl0ZXJhdG9yKGNvbGxlY3Rpb24pIHtcbiAgaWYgKGNvbGxlY3Rpb24gIT0gbnVsbCkge1xuICAgIHZhciBpdGVyYXRvciA9IGdldEl0ZXJhdG9yKGNvbGxlY3Rpb24pXG4gICAgaWYgKGl0ZXJhdG9yKSB7XG4gICAgICByZXR1cm4gaXRlcmF0b3JcbiAgICB9XG4gICAgaWYgKGlzQXJyYXlMaWtlKGNvbGxlY3Rpb24pKSB7XG4gICAgICByZXR1cm4gbmV3IEFycmF5TGlrZUl0ZXJhdG9yKGNvbGxlY3Rpb24pXG4gICAgfVxuICB9XG59XG5cbi8vIFdoZW4gdGhlIG9iamVjdCBwcm92aWRlZCB0byBgY3JlYXRlSXRlcmF0b3JgIGlzIG5vdCBJdGVyYWJsZSBidXQgaXNcbi8vIEFycmF5LWxpa2UsIHRoaXMgc2ltcGxlIEl0ZXJhdG9yIGlzIGNyZWF0ZWQuXG5mdW5jdGlvbiBBcnJheUxpa2VJdGVyYXRvcihvYmopIHtcbiAgdGhpcy5fbyA9IG9ialxuICB0aGlzLl9pID0gMFxufVxuXG4vLyBOb3RlOiBhbGwgSXRlcmF0b3JzIGFyZSB0aGVtc2VsdmVzIEl0ZXJhYmxlLlxuQXJyYXlMaWtlSXRlcmF0b3IucHJvdG90eXBlWyQkaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzXG59XG5cbi8vIEEgc2ltcGxlIHN0YXRlLW1hY2hpbmUgZGV0ZXJtaW5lcyB0aGUgSXRlcmF0b3JSZXN1bHQgcmV0dXJuZWQsIHlpZWxkaW5nXG4vLyBlYWNoIHZhbHVlIGluIHRoZSBBcnJheS1saWtlIG9iamVjdCBpbiBvcmRlciBvZiB0aGVpciBpbmRpY2llcy5cbkFycmF5TGlrZUl0ZXJhdG9yLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLl9vID09PSB2b2lkIDAgfHwgdGhpcy5faSA+PSB0aGlzLl9vLmxlbmd0aCkge1xuICAgIHRoaXMuX28gPSB2b2lkIDBcbiAgICByZXR1cm4geyB2YWx1ZTogdm9pZCAwLCBkb25lOiB0cnVlIH1cbiAgfVxuICByZXR1cm4geyB2YWx1ZTogdGhpcy5fb1t0aGlzLl9pKytdLCBkb25lOiBmYWxzZSB9XG59XG5cbi8qKlxuICogR2l2ZW4gYW4gb2JqZWN0IHdoaWNoIGVpdGhlciBpbXBsZW1lbnRzIHRoZSBJdGVyYWJsZSBwcm90b2NvbCBvciBpc1xuICogQXJyYXktbGlrZSwgaXRlcmF0ZSBvdmVyIGl0LCBjYWxsaW5nIHRoZSBgY2FsbGJhY2tgIGF0IGVhY2ggaXRlcmF0aW9uLlxuICpcbiAqIFVzZSBgZm9yRWFjaGAgd2hlcmUgeW91IHdvdWxkIGV4cGVjdCB0byB1c2UgYSBgZm9yIC4uLiBvZmAgbG9vcCBpbiBFUzYuXG4gKiBIb3dldmVyIGBmb3JFYWNoYCBhZGhlcmVzIHRvIHRoZSBiZWhhdmlvciBvZiBbQXJyYXkjZm9yRWFjaF1bXSBkZXNjcmliZWQgaW5cbiAqIHRoZSBFQ01BU2NyaXB0IHNwZWNpZmljYXRpb24sIHNraXBwaW5nIG92ZXIgXCJob2xlc1wiIGluIEFycmF5LWxpa2VzLiBJdCB3aWxsXG4gKiBhbHNvIGRlbGVnYXRlIHRvIGEgYGZvckVhY2hgIG1ldGhvZCBvbiBgY29sbGVjdGlvbmAgaWYgb25lIGlzIGRlZmluZWQsXG4gKiBlbnN1cmluZyBuYXRpdmUgcGVyZm9ybWFuY2UgZm9yIGBBcnJheXNgLlxuICpcbiAqIFNpbWlsYXIgdG8gW0FycmF5I2ZvckVhY2hdW10sIHRoZSBgY2FsbGJhY2tgIGZ1bmN0aW9uIGFjY2VwdHMgdGhyZWVcbiAqIGFyZ3VtZW50cywgYW5kIGlzIHByb3ZpZGVkIHdpdGggYHRoaXNBcmdgIGFzIHRoZSBjYWxsaW5nIGNvbnRleHQuXG4gKlxuICogTm90ZTogcHJvdmlkaW5nIGFuIGluZmluaXRlIEl0ZXJhdG9yIHRvIGZvckVhY2ggd2lsbCBwcm9kdWNlIGFuIGVycm9yLlxuICpcbiAqIFtBcnJheSNmb3JFYWNoXTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvZm9yRWFjaFxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIGZvckVhY2ggPSByZXF1aXJlKCdpdGVyYWxsJykuZm9yRWFjaFxuICpcbiAqIGZvckVhY2gobXlJdGVyYWJsZSwgZnVuY3Rpb24gKHZhbHVlLCBpbmRleCwgaXRlcmFibGUpIHtcbiAqICAgY29uc29sZS5sb2codmFsdWUsIGluZGV4LCBpdGVyYWJsZSA9PT0gbXlJdGVyYWJsZSlcbiAqIH0pXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBFUzY6XG4gKiBmb3IgKGxldCB2YWx1ZSBvZiBteUl0ZXJhYmxlKSB7XG4gKiAgIGNvbnNvbGUubG9nKHZhbHVlKVxuICogfVxuICpcbiAqIC8vIEFueSBKYXZhU2NyaXB0IGVudmlyb25tZW50OlxuICogZm9yRWFjaChteUl0ZXJhYmxlLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAqICAgY29uc29sZS5sb2codmFsdWUpXG4gKiB9KVxuICpcbiAqIEB0ZW1wbGF0ZSBUIHRoZSB0eXBlIG9mIGVhY2ggaXRlcmF0ZWQgdmFsdWVcbiAqIEBwYXJhbSB7SXRlcmFibGU8VD58eyBsZW5ndGg6IG51bWJlciB9fSBjb2xsZWN0aW9uXG4gKiAgIFRoZSBJdGVyYWJsZSBvciBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKFQsIG51bWJlciwgb2JqZWN0KX0gY2FsbGJhY2tcbiAqICAgRnVuY3Rpb24gdG8gZXhlY3V0ZSBmb3IgZWFjaCBpdGVyYXRpb24sIHRha2luZyB1cCB0byB0aHJlZSBhcmd1bWVudHNcbiAqIEBwYXJhbSBbdGhpc0FyZ11cbiAqICAgT3B0aW9uYWwuIFZhbHVlIHRvIHVzZSBhcyBgdGhpc2Agd2hlbiBleGVjdXRpbmcgYGNhbGxiYWNrYC5cbiAqL1xuLyo6OiBkZWNsYXJlIGV4cG9ydCB2YXIgZm9yRWFjaDpcbiAgJiAoPCtUVmFsdWUsIFRDb2xsZWN0aW9uOiBJdGVyYWJsZTxUVmFsdWU+PihcbiAgICAgIGNvbGxlY3Rpb246IFRDb2xsZWN0aW9uLFxuICAgICAgY2FsbGJhY2tGbjogKHZhbHVlOiBUVmFsdWUsIGluZGV4OiBudW1iZXIsIGNvbGxlY3Rpb246IFRDb2xsZWN0aW9uKSA9PiBhbnksXG4gICAgICB0aGlzQXJnPzogYW55XG4gICAgKSA9PiB2b2lkKVxuICAmICg8VENvbGxlY3Rpb246IHtsZW5ndGg6IG51bWJlcn0+KFxuICAgICAgY29sbGVjdGlvbjogVENvbGxlY3Rpb24sXG4gICAgICBjYWxsYmFja0ZuOiAodmFsdWU6IG1peGVkLCBpbmRleDogbnVtYmVyLCBjb2xsZWN0aW9uOiBUQ29sbGVjdGlvbikgPT4gYW55LFxuICAgICAgdGhpc0FyZz86IGFueVxuICAgICkgPT4gdm9pZCk7ICovXG5leHBvcnQgZnVuY3Rpb24gZm9yRWFjaChjb2xsZWN0aW9uLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICBpZiAoY29sbGVjdGlvbiAhPSBudWxsKSB7XG4gICAgaWYgKHR5cGVvZiBjb2xsZWN0aW9uLmZvckVhY2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBjb2xsZWN0aW9uLmZvckVhY2goY2FsbGJhY2ssIHRoaXNBcmcpXG4gICAgfVxuICAgIHZhciBpID0gMFxuICAgIHZhciBpdGVyYXRvciA9IGdldEl0ZXJhdG9yKGNvbGxlY3Rpb24pXG4gICAgaWYgKGl0ZXJhdG9yKSB7XG4gICAgICB2YXIgc3RlcFxuICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICBjYWxsYmFjay5jYWxsKHRoaXNBcmcsIHN0ZXAudmFsdWUsIGkrKywgY29sbGVjdGlvbilcbiAgICAgICAgLy8gSW5maW5pdGUgSXRlcmF0b3JzIGNvdWxkIGNhdXNlIGZvckVhY2ggdG8gcnVuIGZvcmV2ZXIuXG4gICAgICAgIC8vIEFmdGVyIGEgdmVyeSBsYXJnZSBudW1iZXIgb2YgaXRlcmF0aW9ucywgcHJvZHVjZSBhbiBlcnJvci5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmIChpID4gOTk5OTk5OSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ05lYXItaW5maW5pdGUgaXRlcmF0aW9uLicpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzQXJyYXlMaWtlKGNvbGxlY3Rpb24pKSB7XG4gICAgICBmb3IgKDsgaSA8IGNvbGxlY3Rpb24ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGNvbGxlY3Rpb24uaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgICBjYWxsYmFjay5jYWxsKHRoaXNBcmcsIGNvbGxlY3Rpb25baV0sIGksIGNvbGxlY3Rpb24pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vXG4vLyAgICAgICAgICAgICAgICAgQVNZTkMgSVRFUkFUT1JTICAgICAgICAgICAgICAgICAvL1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8qKlxuICogW0FzeW5jSXRlcmFibGVdKGh0dHBzOi8vdGMzOS5naXRodWIuaW8vcHJvcG9zYWwtYXN5bmMtaXRlcmF0aW9uLyNzZWMtYXN5bmNpdGVyYWJsZS1pbnRlcmZhY2UpXG4gKiBpcyBhICpwcm90b2NvbCogd2hpY2ggd2hlbiBpbXBsZW1lbnRlZCBhbGxvd3MgYSBKYXZhU2NyaXB0IG9iamVjdCB0byBkZWZpbmVcbiAqIGFuIGFzeW5jaHJvbm91cyBpdGVyYXRpb24gYmVoYXZpb3IsIHN1Y2ggYXMgd2hhdCB2YWx1ZXMgYXJlIGxvb3BlZCBvdmVyIGluXG4gKiBhIFtgZm9yLWF3YWl0LW9mYF0oaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9wcm9wb3NhbC1hc3luYy1pdGVyYXRpb24vI3NlYy1mb3ItaW4tYW5kLWZvci1vZi1zdGF0ZW1lbnRzKVxuICogbG9vcCBvciBgaXRlcmFsbGAncyB7QGxpbmsgZm9yQXdhaXRFYWNofSBmdW5jdGlvbi5cbiAqXG4gKiBXaGlsZSBkZXNjcmliZWQgYXMgYSBwcm9wb3NlZCBhZGRpdGlvbiB0byB0aGUgW0VTMjAxNyB2ZXJzaW9uIG9mIEphdmFTY3JpcHRdKGh0dHBzOi8vdGMzOS5naXRodWIuaW8vcHJvcG9zYWwtYXN5bmMtaXRlcmF0aW9uLylcbiAqIGl0IGNhbiBiZSB1dGlsaXplZCBieSBhbnkgdmVyc2lvbiBvZiBKYXZhU2NyaXB0LlxuICpcbiAqIEBleHRlcm5hbCBBc3luY0l0ZXJhYmxlXG4gKiBAc2VlIHtAbGluayBodHRwczovL3RjMzkuZ2l0aHViLmlvL3Byb3Bvc2FsLWFzeW5jLWl0ZXJhdGlvbi8jc2VjLWFzeW5jaXRlcmFibGUtaW50ZXJmYWNlfEFzeW5jIEl0ZXJhdGlvbiBQcm9wb3NhbH1cbiAqIEB0ZW1wbGF0ZSBUIFRoZSB0eXBlIG9mIGVhY2ggaXRlcmF0ZWQgdmFsdWVcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb24gKCk6IEFzeW5jSXRlcmF0b3I8VD59IFN5bWJvbC5hc3luY0l0ZXJhdG9yXG4gKiAgIEEgbWV0aG9kIHdoaWNoIHByb2R1Y2VzIGFuIEFzeW5jSXRlcmF0b3IgZm9yIHRoaXMgQXN5bmNJdGVyYWJsZS5cbiAqL1xuXG4vKipcbiAqIFtBc3luY0l0ZXJhdG9yXShodHRwczovL3RjMzkuZ2l0aHViLmlvL3Byb3Bvc2FsLWFzeW5jLWl0ZXJhdGlvbi8jc2VjLWFzeW5jaXRlcmF0b3ItaW50ZXJmYWNlKVxuICogaXMgYSAqcHJvdG9jb2wqIHdoaWNoIGRlc2NyaWJlcyBhIHN0YW5kYXJkIHdheSB0byBwcm9kdWNlIGFuZCBjb25zdW1lIGFuXG4gKiBhc3luY2hyb25vdXMgc2VxdWVuY2Ugb2YgdmFsdWVzLCB0eXBpY2FsbHkgdGhlIHZhbHVlcyBvZiB0aGVcbiAqIHtAbGluayBBc3luY0l0ZXJhYmxlfSByZXByZXNlbnRlZCBieSB0aGlzIHtAbGluayBBc3luY0l0ZXJhdG9yfS5cbiAqXG4gKiBBc3luY0l0ZXJhdG9yIGlzIHNpbWlsYXIgdG8gT2JzZXJ2YWJsZSBvciBTdHJlYW0uIExpa2UgYW4ge0BsaW5rIEl0ZXJhdG9yfSBpdFxuICogYWxzbyBhcyBhIGBuZXh0KClgIG1ldGhvZCwgaG93ZXZlciBpbnN0ZWFkIG9mIGFuIEl0ZXJhdG9yUmVzdWx0LFxuICogY2FsbGluZyB0aGlzIG1ldGhvZCByZXR1cm5zIGEge0BsaW5rIFByb21pc2V9IGZvciBhIEl0ZXJhdG9yUmVzdWx0LlxuICpcbiAqIFdoaWxlIGRlc2NyaWJlZCBhcyBhIHByb3Bvc2VkIGFkZGl0aW9uIHRvIHRoZSBbRVMyMDE3IHZlcnNpb24gb2YgSmF2YVNjcmlwdF0oaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9wcm9wb3NhbC1hc3luYy1pdGVyYXRpb24vKVxuICogaXQgY2FuIGJlIHV0aWxpemVkIGJ5IGFueSB2ZXJzaW9uIG9mIEphdmFTY3JpcHQuXG4gKlxuICogQGV4dGVybmFsIEFzeW5jSXRlcmF0b3JcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vcHJvcG9zYWwtYXN5bmMtaXRlcmF0aW9uLyNzZWMtYXN5bmNpdGVyYXRvci1pbnRlcmZhY2V8QXN5bmMgSXRlcmF0aW9uIFByb3Bvc2FsfVxuICovXG5cbi8vIEluIEVTMjAxNyAob3IgYSBwb2x5ZmlsbGVkKSBlbnZpcm9ubWVudCwgdGhpcyB3aWxsIGJlIFN5bWJvbC5hc3luY0l0ZXJhdG9yXG52YXIgU1lNQk9MX0FTWU5DX0lURVJBVE9SID0gU1lNQk9MICYmIFNZTUJPTC5hc3luY0l0ZXJhdG9yXG5cbi8qKlxuICogQSBwcm9wZXJ0eSBuYW1lIHRvIGJlIHVzZWQgYXMgdGhlIG5hbWUgb2YgYW4gQXN5bmNJdGVyYWJsZSdzIG1ldGhvZFxuICogcmVzcG9uc2libGUgZm9yIHByb2R1Y2luZyBhbiBJdGVyYXRvciwgcmVmZXJyZWQgdG8gYXMgYEBAYXN5bmNJdGVyYXRvcmAuXG4gKiBUeXBpY2FsbHkgcmVwcmVzZW50cyB0aGUgdmFsdWUgYFN5bWJvbC5hc3luY0l0ZXJhdG9yYCBidXQgZmFsbHMgYmFjayB0byB0aGVcbiAqIHN0cmluZyBgXCJAQGFzeW5jSXRlcmF0b3JcImAgd2hlbiBgU3ltYm9sLmFzeW5jSXRlcmF0b3JgIGlzIG5vdCBkZWZpbmVkLlxuICpcbiAqIFVzZSBgJCRhc3luY0l0ZXJhdG9yYCBmb3IgZGVmaW5pbmcgbmV3IEFzeW5jSXRlcmFibGVzIGluc3RlYWQgb2ZcbiAqIGBTeW1ib2wuYXN5bmNJdGVyYXRvcmAsIGJ1dCBkbyBub3QgdXNlIGl0IGZvciBhY2Nlc3NpbmcgZXhpc3RpbmcgSXRlcmFibGVzLFxuICogaW5zdGVhZCB1c2Uge0BsaW5rIGdldEFzeW5jSXRlcmF0b3J9IG9yIHtAbGluayBpc0FzeW5jSXRlcmFibGV9LlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogdmFyICQkYXN5bmNJdGVyYXRvciA9IHJlcXVpcmUoJ2l0ZXJhbGwnKS4kJGFzeW5jSXRlcmF0b3JcbiAqXG4gKiBmdW5jdGlvbiBDaGlycGVyICh0bykge1xuICogICB0aGlzLnRvID0gdG9cbiAqIH1cbiAqXG4gKiBDaGlycGVyLnByb3RvdHlwZVskJGFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkge1xuICogICByZXR1cm4ge1xuICogICAgIHRvOiB0aGlzLnRvLFxuICogICAgIG51bTogMCxcbiAqICAgICBuZXh0ICgpIHtcbiAqICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAqICAgICAgICAgaWYgKHRoaXMubnVtID49IHRoaXMudG8pIHtcbiAqICAgICAgICAgICByZXNvbHZlKHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9KVxuICogICAgICAgICB9IGVsc2Uge1xuICogICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICogICAgICAgICAgICAgcmVzb2x2ZSh7IHZhbHVlOiB0aGlzLm51bSsrLCBkb25lOiBmYWxzZSB9KVxuICogICAgICAgICAgIH0sIDEwMDApXG4gKiAgICAgICAgIH1cbiAqICAgICAgIH0pXG4gKiAgICAgfVxuICogICB9XG4gKiB9XG4gKlxuICogdmFyIGNoaXJwZXIgPSBuZXcgQ2hpcnBlcigzKVxuICogZm9yIGF3YWl0ICh2YXIgbnVtYmVyIG9mIGNoaXJwZXIpIHtcbiAqICAgY29uc29sZS5sb2cobnVtYmVyKSAvLyAwIC4uLndhaXQuLi4gMSAuLi53YWl0Li4uIDJcbiAqIH1cbiAqXG4gKiBAdHlwZSB7U3ltYm9sfHN0cmluZ31cbiAqL1xuLyo6OiBkZWNsYXJlIGV4cG9ydCB2YXIgJCRhc3luY0l0ZXJhdG9yOiAnQEBhc3luY0l0ZXJhdG9yJzsgKi9cbmV4cG9ydCB2YXIgJCRhc3luY0l0ZXJhdG9yID0gU1lNQk9MX0FTWU5DX0lURVJBVE9SIHx8ICdAQGFzeW5jSXRlcmF0b3InXG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBwcm92aWRlZCBvYmplY3QgaW1wbGVtZW50cyB0aGUgQXN5bmNJdGVyYXRvciBwcm90b2NvbCB2aWFcbiAqIGVpdGhlciBpbXBsZW1lbnRpbmcgYSBgU3ltYm9sLmFzeW5jSXRlcmF0b3JgIG9yIGBcIkBAYXN5bmNJdGVyYXRvclwiYCBtZXRob2QuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgaXNBc3luY0l0ZXJhYmxlID0gcmVxdWlyZSgnaXRlcmFsbCcpLmlzQXN5bmNJdGVyYWJsZVxuICogaXNBc3luY0l0ZXJhYmxlKG15U3RyZWFtKSAvLyB0cnVlXG4gKiBpc0FzeW5jSXRlcmFibGUoJ0FCQycpIC8vIGZhbHNlXG4gKlxuICogQHBhcmFtIG9ialxuICogICBBIHZhbHVlIHdoaWNoIG1pZ2h0IGltcGxlbWVudCB0aGUgQXN5bmNJdGVyYWJsZSBwcm90b2NvbC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgQXN5bmNJdGVyYWJsZS5cbiAqL1xuLyo6OiBkZWNsYXJlIGV4cG9ydCBmdW5jdGlvbiBpc0FzeW5jSXRlcmFibGUob2JqOiBhbnkpOiBib29sZWFuOyAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzQXN5bmNJdGVyYWJsZShvYmopIHtcbiAgcmV0dXJuICEhZ2V0QXN5bmNJdGVyYXRvck1ldGhvZChvYmopXG59XG5cbi8qKlxuICogSWYgdGhlIHByb3ZpZGVkIG9iamVjdCBpbXBsZW1lbnRzIHRoZSBBc3luY0l0ZXJhdG9yIHByb3RvY29sLCBpdHNcbiAqIEFzeW5jSXRlcmF0b3Igb2JqZWN0IGlzIHJldHVybmVkLiBPdGhlcndpc2UgcmV0dXJucyB1bmRlZmluZWQuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgZ2V0QXN5bmNJdGVyYXRvciA9IHJlcXVpcmUoJ2l0ZXJhbGwnKS5nZXRBc3luY0l0ZXJhdG9yXG4gKiB2YXIgYXN5bmNJdGVyYXRvciA9IGdldEFzeW5jSXRlcmF0b3IobXlTdHJlYW0pXG4gKiBhc3luY0l0ZXJhdG9yLm5leHQoKS50aGVuKGNvbnNvbGUubG9nKSAvLyB7IHZhbHVlOiAxLCBkb25lOiBmYWxzZSB9XG4gKiBhc3luY0l0ZXJhdG9yLm5leHQoKS50aGVuKGNvbnNvbGUubG9nKSAvLyB7IHZhbHVlOiAyLCBkb25lOiBmYWxzZSB9XG4gKiBhc3luY0l0ZXJhdG9yLm5leHQoKS50aGVuKGNvbnNvbGUubG9nKSAvLyB7IHZhbHVlOiAzLCBkb25lOiBmYWxzZSB9XG4gKiBhc3luY0l0ZXJhdG9yLm5leHQoKS50aGVuKGNvbnNvbGUubG9nKSAvLyB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfVxuICpcbiAqIEB0ZW1wbGF0ZSBUIHRoZSB0eXBlIG9mIGVhY2ggaXRlcmF0ZWQgdmFsdWVcbiAqIEBwYXJhbSB7QXN5bmNJdGVyYWJsZTxUPn0gYXN5bmNJdGVyYWJsZVxuICogICBBbiBBc3luY0l0ZXJhYmxlIG9iamVjdCB3aGljaCBpcyB0aGUgc291cmNlIG9mIGFuIEFzeW5jSXRlcmF0b3IuXG4gKiBAcmV0dXJuIHtBc3luY0l0ZXJhdG9yPFQ+fSBuZXcgQXN5bmNJdGVyYXRvciBpbnN0YW5jZS5cbiAqL1xuLyo6OiBkZWNsYXJlIGV4cG9ydCB2YXIgZ2V0QXN5bmNJdGVyYXRvcjpcbiAgJiAoPCtUVmFsdWU+KGFzeW5jSXRlcmFibGU6IEFzeW5jSXRlcmFibGU8VFZhbHVlPikgPT4gQXN5bmNJdGVyYXRvcjxUVmFsdWU+KVxuICAmICgoYXN5bmNJdGVyYWJsZTogbWl4ZWQpID0+ICh2b2lkIHwgQXN5bmNJdGVyYXRvcjxtaXhlZD4pKTsgKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRBc3luY0l0ZXJhdG9yKGFzeW5jSXRlcmFibGUpIHtcbiAgdmFyIG1ldGhvZCA9IGdldEFzeW5jSXRlcmF0b3JNZXRob2QoYXN5bmNJdGVyYWJsZSlcbiAgaWYgKG1ldGhvZCkge1xuICAgIHJldHVybiBtZXRob2QuY2FsbChhc3luY0l0ZXJhYmxlKVxuICB9XG59XG5cbi8qKlxuICogSWYgdGhlIHByb3ZpZGVkIG9iamVjdCBpbXBsZW1lbnRzIHRoZSBBc3luY0l0ZXJhdG9yIHByb3RvY29sLCB0aGUgbWV0aG9kXG4gKiByZXNwb25zaWJsZSBmb3IgcHJvZHVjaW5nIGl0cyBBc3luY0l0ZXJhdG9yIG9iamVjdCBpcyByZXR1cm5lZC5cbiAqXG4gKiBUaGlzIGlzIHVzZWQgaW4gcmFyZSBjYXNlcyBmb3IgcGVyZm9ybWFuY2UgdHVuaW5nLiBUaGlzIG1ldGhvZCBtdXN0IGJlIGNhbGxlZFxuICogd2l0aCBvYmogYXMgdGhlIGNvbnRleHR1YWwgdGhpcy1hcmd1bWVudC5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBnZXRBc3luY0l0ZXJhdG9yTWV0aG9kID0gcmVxdWlyZSgnaXRlcmFsbCcpLmdldEFzeW5jSXRlcmF0b3JNZXRob2RcbiAqIHZhciBtZXRob2QgPSBnZXRBc3luY0l0ZXJhdG9yTWV0aG9kKG15U3RyZWFtKVxuICogaWYgKG1ldGhvZCkge1xuICogICB2YXIgYXN5bmNJdGVyYXRvciA9IG1ldGhvZC5jYWxsKG15U3RyZWFtKVxuICogfVxuICpcbiAqIEB0ZW1wbGF0ZSBUIHRoZSB0eXBlIG9mIGVhY2ggaXRlcmF0ZWQgdmFsdWVcbiAqIEBwYXJhbSB7QXN5bmNJdGVyYWJsZTxUPn0gYXN5bmNJdGVyYWJsZVxuICogICBBbiBBc3luY0l0ZXJhYmxlIG9iamVjdCB3aGljaCBkZWZpbmVzIGFuIGBAQGFzeW5jSXRlcmF0b3JgIG1ldGhvZC5cbiAqIEByZXR1cm4ge2Z1bmN0aW9uKCk6IEFzeW5jSXRlcmF0b3I8VD59IGBAQGFzeW5jSXRlcmF0b3JgIG1ldGhvZC5cbiAqL1xuLyo6OiBkZWNsYXJlIGV4cG9ydCB2YXIgZ2V0QXN5bmNJdGVyYXRvck1ldGhvZDpcbiAgJiAoPCtUVmFsdWU+KGFzeW5jSXRlcmFibGU6IEFzeW5jSXRlcmFibGU8VFZhbHVlPikgPT4gKCgpID0+IEFzeW5jSXRlcmF0b3I8VFZhbHVlPikpXG4gICYgKChhc3luY0l0ZXJhYmxlOiBtaXhlZCkgPT4gKHZvaWQgfCAoKCkgPT4gQXN5bmNJdGVyYXRvcjxtaXhlZD4pKSk7ICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0QXN5bmNJdGVyYXRvck1ldGhvZChhc3luY0l0ZXJhYmxlKSB7XG4gIGlmIChhc3luY0l0ZXJhYmxlICE9IG51bGwpIHtcbiAgICB2YXIgbWV0aG9kID1cbiAgICAgIChTWU1CT0xfQVNZTkNfSVRFUkFUT1IgJiYgYXN5bmNJdGVyYWJsZVtTWU1CT0xfQVNZTkNfSVRFUkFUT1JdKSB8fFxuICAgICAgYXN5bmNJdGVyYWJsZVsnQEBhc3luY0l0ZXJhdG9yJ11cbiAgICBpZiAodHlwZW9mIG1ldGhvZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIG1ldGhvZFxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFNpbWlsYXIgdG8ge0BsaW5rIGdldEFzeW5jSXRlcmF0b3J9LCB0aGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IEFzeW5jSXRlcmF0b3JcbiAqIGdpdmVuIGFuIEFzeW5jSXRlcmFibGUuIEhvd2V2ZXIgaXQgd2lsbCBhbHNvIGNyZWF0ZSBhbiBBc3luY0l0ZXJhdG9yIGZvciBhXG4gKiBub24tYXN5bmMgSXRlcmFibGUgYXMgd2VsbCBhcyBub24tSXRlcmFibGUgQXJyYXktbGlrZSBjb2xsZWN0aW9uLCBzdWNoIGFzXG4gKiBBcnJheSBpbiBhIHByZS1FUzIwMTUgZW52aXJvbm1lbnQuXG4gKlxuICogYGNyZWF0ZUFzeW5jSXRlcmF0b3JgIGlzIGNvbXBsaW1lbnRhcnkgdG8gYGZvckF3YWl0RWFjaGAsIGJ1dCBhbGxvd3MgYVxuICogYnVmZmVyaW5nIFwicHVsbFwiLWJhc2VkIGl0ZXJhdGlvbiBhcyBvcHBvc2VkIHRvIGBmb3JBd2FpdEVhY2hgJ3NcbiAqIFwicHVzaFwiLWJhc2VkIGl0ZXJhdGlvbi5cbiAqXG4gKiBgY3JlYXRlQXN5bmNJdGVyYXRvcmAgcHJvZHVjZXMgYW4gQXN5bmNJdGVyYXRvciBmb3Igbm9uLWFzeW5jIEl0ZXJhYmxlcyBhc1xuICogZGVzY3JpYmVkIGluIHRoZSBFQ01BU2NyaXB0IHByb3Bvc2FsIFtBc3luYy1mcm9tLVN5bmMgSXRlcmF0b3IgT2JqZWN0c10oaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9wcm9wb3NhbC1hc3luYy1pdGVyYXRpb24vI3NlYy1hc3luYy1mcm9tLXN5bmMtaXRlcmF0b3Itb2JqZWN0cykuXG4gKlxuICogPiBOb3RlOiBDcmVhdGluZyBgQXN5bmNJdGVyYXRvcmBzIHJlcXVpcmVzIHRoZSBleGlzdGVuY2Ugb2YgYFByb21pc2VgLlxuICogPiBXaGlsZSBgUHJvbWlzZWAgaGFzIGJlZW4gYXZhaWxhYmxlIGluIG1vZGVybiBicm93c2VycyBmb3IgYSBudW1iZXIgb2ZcbiAqID4geWVhcnMsIGxlZ2FjeSBicm93c2VycyAobGlrZSBJRSAxMSkgbWF5IHJlcXVpcmUgYSBwb2x5ZmlsbC5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBjcmVhdGVBc3luY0l0ZXJhdG9yID0gcmVxdWlyZSgnaXRlcmFsbCcpLmNyZWF0ZUFzeW5jSXRlcmF0b3JcbiAqXG4gKiB2YXIgbXlBcnJheWxpa2UgPSB7IGxlbmd0aDogMywgMDogJ0FscGhhJywgMTogJ0JyYXZvJywgMjogJ0NoYXJsaWUnIH1cbiAqIHZhciBpdGVyYXRvciA9IGNyZWF0ZUFzeW5jSXRlcmF0b3IobXlBcnJheWxpa2UpXG4gKiBpdGVyYXRvci5uZXh0KCkudGhlbihjb25zb2xlLmxvZykgLy8geyB2YWx1ZTogJ0FscGhhJywgZG9uZTogZmFsc2UgfVxuICogaXRlcmF0b3IubmV4dCgpLnRoZW4oY29uc29sZS5sb2cpIC8vIHsgdmFsdWU6ICdCcmF2bycsIGRvbmU6IGZhbHNlIH1cbiAqIGl0ZXJhdG9yLm5leHQoKS50aGVuKGNvbnNvbGUubG9nKSAvLyB7IHZhbHVlOiAnQ2hhcmxpZScsIGRvbmU6IGZhbHNlIH1cbiAqIGl0ZXJhdG9yLm5leHQoKS50aGVuKGNvbnNvbGUubG9nKSAvLyB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfVxuICpcbiAqIEB0ZW1wbGF0ZSBUIHRoZSB0eXBlIG9mIGVhY2ggaXRlcmF0ZWQgdmFsdWVcbiAqIEBwYXJhbSB7QXN5bmNJdGVyYWJsZTxUPnxJdGVyYWJsZTxUPnx7IGxlbmd0aDogbnVtYmVyIH19IHNvdXJjZVxuICogICBBbiBBc3luY0l0ZXJhYmxlLCBJdGVyYWJsZSwgb3IgQXJyYXktbGlrZSBvYmplY3QgdG8gcHJvZHVjZSBhbiBJdGVyYXRvci5cbiAqIEByZXR1cm4ge0FzeW5jSXRlcmF0b3I8VD59IG5ldyBBc3luY0l0ZXJhdG9yIGluc3RhbmNlLlxuICovXG4vKjo6IGRlY2xhcmUgZXhwb3J0IHZhciBjcmVhdGVBc3luY0l0ZXJhdG9yOlxuICAmICg8K1RWYWx1ZT4oXG4gICAgICBjb2xsZWN0aW9uOiBJdGVyYWJsZTxQcm9taXNlPFRWYWx1ZT4gfCBUVmFsdWU+IHwgQXN5bmNJdGVyYWJsZTxUVmFsdWU+XG4gICAgKSA9PiBBc3luY0l0ZXJhdG9yPFRWYWx1ZT4pXG4gICYgKChjb2xsZWN0aW9uOiB7bGVuZ3RoOiBudW1iZXJ9KSA9PiBBc3luY0l0ZXJhdG9yPG1peGVkPilcbiAgJiAoKGNvbGxlY3Rpb246IG1peGVkKSA9PiAodm9pZCB8IEFzeW5jSXRlcmF0b3I8bWl4ZWQ+KSk7ICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQXN5bmNJdGVyYXRvcihzb3VyY2UpIHtcbiAgaWYgKHNvdXJjZSAhPSBudWxsKSB7XG4gICAgdmFyIGFzeW5jSXRlcmF0b3IgPSBnZXRBc3luY0l0ZXJhdG9yKHNvdXJjZSlcbiAgICBpZiAoYXN5bmNJdGVyYXRvcikge1xuICAgICAgcmV0dXJuIGFzeW5jSXRlcmF0b3JcbiAgICB9XG4gICAgdmFyIGl0ZXJhdG9yID0gY3JlYXRlSXRlcmF0b3Ioc291cmNlKVxuICAgIGlmIChpdGVyYXRvcikge1xuICAgICAgcmV0dXJuIG5ldyBBc3luY0Zyb21TeW5jSXRlcmF0b3IoaXRlcmF0b3IpXG4gICAgfVxuICB9XG59XG5cbi8vIFdoZW4gdGhlIG9iamVjdCBwcm92aWRlZCB0byBgY3JlYXRlQXN5bmNJdGVyYXRvcmAgaXMgbm90IEFzeW5jSXRlcmFibGUgYnV0IGlzXG4vLyBzeW5jIEl0ZXJhYmxlLCB0aGlzIHNpbXBsZSB3cmFwcGVyIGlzIGNyZWF0ZWQuXG5mdW5jdGlvbiBBc3luY0Zyb21TeW5jSXRlcmF0b3IoaXRlcmF0b3IpIHtcbiAgdGhpcy5faSA9IGl0ZXJhdG9yXG59XG5cbi8vIE5vdGU6IGFsbCBBc3luY0l0ZXJhdG9ycyBhcmUgdGhlbXNlbHZlcyBBc3luY0l0ZXJhYmxlLlxuQXN5bmNGcm9tU3luY0l0ZXJhdG9yLnByb3RvdHlwZVskJGFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzXG59XG5cbi8vIEEgc2ltcGxlIHN0YXRlLW1hY2hpbmUgZGV0ZXJtaW5lcyB0aGUgSXRlcmF0b3JSZXN1bHQgcmV0dXJuZWQsIHlpZWxkaW5nXG4vLyBlYWNoIHZhbHVlIGluIHRoZSBBcnJheS1saWtlIG9iamVjdCBpbiBvcmRlciBvZiB0aGVpciBpbmRpY2llcy5cbkFzeW5jRnJvbVN5bmNJdGVyYXRvci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiB1bndyYXBBc3luY0Zyb21TeW5jKHRoaXMuX2ksICduZXh0JywgdmFsdWUpXG59XG5cbkFzeW5jRnJvbVN5bmNJdGVyYXRvci5wcm90b3R5cGUucmV0dXJuID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIHRoaXMuX2kucmV0dXJuXG4gICAgPyB1bndyYXBBc3luY0Zyb21TeW5jKHRoaXMuX2ksICdyZXR1cm4nLCB2YWx1ZSlcbiAgICA6IFByb21pc2UucmVzb2x2ZSh7IHZhbHVlOiB2YWx1ZSwgZG9uZTogdHJ1ZSB9KVxufVxuXG5Bc3luY0Zyb21TeW5jSXRlcmF0b3IucHJvdG90eXBlLnRocm93ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIHRoaXMuX2kudGhyb3dcbiAgICA/IHVud3JhcEFzeW5jRnJvbVN5bmModGhpcy5faSwgJ3Rocm93JywgdmFsdWUpXG4gICAgOiBQcm9taXNlLnJlamVjdCh2YWx1ZSlcbn1cblxuZnVuY3Rpb24gdW53cmFwQXN5bmNGcm9tU3luYyhpdGVyYXRvciwgZm4sIHZhbHVlKSB7XG4gIHZhciBzdGVwXG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlKSB7XG4gICAgc3RlcCA9IGl0ZXJhdG9yW2ZuXSh2YWx1ZSlcbiAgICByZXNvbHZlKHN0ZXAudmFsdWUpXG4gIH0pLnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4geyB2YWx1ZTogdmFsdWUsIGRvbmU6IHN0ZXAuZG9uZSB9XG4gIH0pXG59XG5cbi8qKlxuICogR2l2ZW4gYW4gb2JqZWN0IHdoaWNoIGVpdGhlciBpbXBsZW1lbnRzIHRoZSBBc3luY0l0ZXJhYmxlIHByb3RvY29sIG9yIGlzXG4gKiBBcnJheS1saWtlLCBpdGVyYXRlIG92ZXIgaXQsIGNhbGxpbmcgdGhlIGBjYWxsYmFja2AgYXQgZWFjaCBpdGVyYXRpb24uXG4gKlxuICogVXNlIGBmb3JBd2FpdEVhY2hgIHdoZXJlIHlvdSB3b3VsZCBleHBlY3QgdG8gdXNlIGEgW2Zvci1hd2FpdC1vZl0oaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9wcm9wb3NhbC1hc3luYy1pdGVyYXRpb24vI3NlYy1mb3ItaW4tYW5kLWZvci1vZi1zdGF0ZW1lbnRzKSBsb29wLlxuICpcbiAqIFNpbWlsYXIgdG8gW0FycmF5I2ZvckVhY2hdW10sIHRoZSBgY2FsbGJhY2tgIGZ1bmN0aW9uIGFjY2VwdHMgdGhyZWVcbiAqIGFyZ3VtZW50cywgYW5kIGlzIHByb3ZpZGVkIHdpdGggYHRoaXNBcmdgIGFzIHRoZSBjYWxsaW5nIGNvbnRleHQuXG4gKlxuICogPiBOb3RlOiBVc2luZyBgZm9yQXdhaXRFYWNoYCByZXF1aXJlcyB0aGUgZXhpc3RlbmNlIG9mIGBQcm9taXNlYC5cbiAqID4gV2hpbGUgYFByb21pc2VgIGhhcyBiZWVuIGF2YWlsYWJsZSBpbiBtb2Rlcm4gYnJvd3NlcnMgZm9yIGEgbnVtYmVyIG9mXG4gKiA+IHllYXJzLCBsZWdhY3kgYnJvd3NlcnMgKGxpa2UgSUUgMTEpIG1heSByZXF1aXJlIGEgcG9seWZpbGwuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgZm9yQXdhaXRFYWNoID0gcmVxdWlyZSgnaXRlcmFsbCcpLmZvckF3YWl0RWFjaFxuICpcbiAqIGZvckF3YWl0RWFjaChteUl0ZXJhYmxlLCBmdW5jdGlvbiAodmFsdWUsIGluZGV4LCBpdGVyYWJsZSkge1xuICogICBjb25zb2xlLmxvZyh2YWx1ZSwgaW5kZXgsIGl0ZXJhYmxlID09PSBteUl0ZXJhYmxlKVxuICogfSlcbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIEVTMjAxNzpcbiAqIGZvciBhd2FpdCAobGV0IHZhbHVlIG9mIG15QXN5bmNJdGVyYWJsZSkge1xuICogICBjb25zb2xlLmxvZyhhd2FpdCBkb1NvbWV0aGluZ0FzeW5jKHZhbHVlKSlcbiAqIH1cbiAqIGNvbnNvbGUubG9nKCdkb25lJylcbiAqXG4gKiAvLyBBbnkgSmF2YVNjcmlwdCBlbnZpcm9ubWVudDpcbiAqIGZvckF3YWl0RWFjaChteUFzeW5jSXRlcmFibGUsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICogICByZXR1cm4gZG9Tb21ldGhpbmdBc3luYyh2YWx1ZSkudGhlbihjb25zb2xlLmxvZylcbiAqIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICogICBjb25zb2xlLmxvZygnZG9uZScpXG4gKiB9KVxuICpcbiAqIEB0ZW1wbGF0ZSBUIHRoZSB0eXBlIG9mIGVhY2ggaXRlcmF0ZWQgdmFsdWVcbiAqIEBwYXJhbSB7QXN5bmNJdGVyYWJsZTxUPnxJdGVyYWJsZTxQcm9taXNlPFQ+IHwgVD58eyBsZW5ndGg6IG51bWJlciB9fSBzb3VyY2VcbiAqICAgVGhlIEFzeW5jSXRlcmFibGUgb3IgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtmdW5jdGlvbihULCBudW1iZXIsIG9iamVjdCl9IGNhbGxiYWNrXG4gKiAgIEZ1bmN0aW9uIHRvIGV4ZWN1dGUgZm9yIGVhY2ggaXRlcmF0aW9uLCB0YWtpbmcgdXAgdG8gdGhyZWUgYXJndW1lbnRzXG4gKiBAcGFyYW0gW3RoaXNBcmddXG4gKiAgIE9wdGlvbmFsLiBWYWx1ZSB0byB1c2UgYXMgYHRoaXNgIHdoZW4gZXhlY3V0aW5nIGBjYWxsYmFja2AuXG4gKi9cbi8qOjogZGVjbGFyZSBleHBvcnQgdmFyIGZvckF3YWl0RWFjaDpcbiAgJiAoPCtUVmFsdWUsIFRDb2xsZWN0aW9uOiBJdGVyYWJsZTxQcm9taXNlPFRWYWx1ZT4gfCBUVmFsdWU+IHwgQXN5bmNJdGVyYWJsZTxUVmFsdWU+PihcbiAgICAgIGNvbGxlY3Rpb246IFRDb2xsZWN0aW9uLFxuICAgICAgY2FsbGJhY2tGbjogKHZhbHVlOiBUVmFsdWUsIGluZGV4OiBudW1iZXIsIGNvbGxlY3Rpb246IFRDb2xsZWN0aW9uKSA9PiBhbnksXG4gICAgICB0aGlzQXJnPzogYW55XG4gICAgKSA9PiBQcm9taXNlPHZvaWQ+KVxuICAmICg8VENvbGxlY3Rpb246IHsgbGVuZ3RoOiBudW1iZXIgfT4oXG4gICAgICBjb2xsZWN0aW9uOiBUQ29sbGVjdGlvbixcbiAgICAgIGNhbGxiYWNrRm46ICh2YWx1ZTogbWl4ZWQsIGluZGV4OiBudW1iZXIsIGNvbGxlY3Rpb246IFRDb2xsZWN0aW9uKSA9PiBhbnksXG4gICAgICB0aGlzQXJnPzogYW55XG4gICAgKSA9PiBQcm9taXNlPHZvaWQ+KTsgKi9cbmV4cG9ydCBmdW5jdGlvbiBmb3JBd2FpdEVhY2goc291cmNlLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICB2YXIgYXN5bmNJdGVyYXRvciA9IGNyZWF0ZUFzeW5jSXRlcmF0b3Ioc291cmNlKVxuICBpZiAoYXN5bmNJdGVyYXRvcikge1xuICAgIHZhciBpID0gMFxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgIGFzeW5jSXRlcmF0b3JcbiAgICAgICAgICAubmV4dCgpXG4gICAgICAgICAgLnRoZW4oZnVuY3Rpb24oc3RlcCkge1xuICAgICAgICAgICAgaWYgKCFzdGVwLmRvbmUpIHtcbiAgICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKGNhbGxiYWNrLmNhbGwodGhpc0FyZywgc3RlcC52YWx1ZSwgaSsrLCBzb3VyY2UpKVxuICAgICAgICAgICAgICAgIC50aGVuKG5leHQpXG4gICAgICAgICAgICAgICAgLmNhdGNoKHJlamVjdClcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlc29sdmUoKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRXhwbGljaXRseSByZXR1cm4gbnVsbCwgc2lsZW5jaW5nIGJsdWViaXJkLXN0eWxlIHdhcm5pbmdzLlxuICAgICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5jYXRjaChyZWplY3QpXG4gICAgICAgIC8vIEV4cGxpY2l0bHkgcmV0dXJuIG51bGwsIHNpbGVuY2luZyBibHVlYmlyZC1zdHlsZSB3YXJuaW5ncy5cbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgIH1cbiAgICAgIG5leHQoKVxuICAgIH0pXG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/iterall/index.mjs\n");

/***/ })

};
;